<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß™ MCP Data Layer - Standalone Testing</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f7fa;
            line-height: 1.6;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
        }
        .test-section {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            margin: 8px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .button:hover { 
            background: #5a67d8; 
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .button-success { background: #48bb78; }
        .button-success:hover { background: #38a169; box-shadow: 0 4px 12px rgba(72, 187, 120, 0.4); }
        .button-danger { background: #f56565; }
        .button-danger:hover { background: #e53e3e; box-shadow: 0 4px 12px rgba(245, 101, 101, 0.4); }
        .button-full { width: 100%; margin: 16px 0; padding: 16px; font-size: 16px; }
        
        .results {
            background: #1a202c;
            color: #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
            font-family: 'Monaco', 'Consolas', monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #2d3748;
        }
        .mock-data {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
        }
        .status {
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            font-weight: 600;
        }
        .status-pass { background: #c6f6d5; color: #22543d; }
        .status-fail { background: #fed7d7; color: #742a2a; }
        .status-warn { background: #fefcbf; color: #744210; }
        .status-info { background: #bee3f8; color: #2c5282; }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
        }
        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üß™ MCP Data Layer - Standalone Testing</h1>
        <p>Comprehensive testing suite for the Figma AI Ticket Generator MCP data layer</p>
        <p><strong>No Figma file required!</strong> Test everything with mock data.</p>
    </div>

    <div class="test-section">
        <h2>üöÄ Quick Start</h2>
        <button id="runAll" class="button button-success button-full">
            üöÄ Run Complete Test Suite
        </button>
        <button id="clearResults" class="button button-danger">Clear Results</button>
    </div>

    <div class="grid">
        <div class="test-section">
            <h3>üîß Server Tests</h3>
            <button id="testServer" class="button">Test MCP Server</button>
            <button id="testAI" class="button">Test AI Generation</button>
            <button id="testGemini" class="button">Test Gemini Direct</button>
        </div>

        <div class="test-section">
            <h3>üìä Data Tests</h3>
            <button id="testValidation" class="button">Test Schema Validation</button>
            <button id="testMockData" class="button">Test Mock Data</button>
            <button id="showMockData" class="button">Show Mock Data</button>
        </div>

        <div class="test-section">
            <h3>üéØ Integration Tests</h3>
            <button id="testFullPipeline" class="button">Test Full Pipeline</button>
            <button id="testTicketGeneration" class="button">Test Ticket Generation</button>
            <button id="testErrorHandling" class="button">Test Error Handling</button>
        </div>

        <div class="test-section">
            <h3>üß™ UI Test Functions</h3>
            <button id="testMockAI" class="button">Test Mock AI Generation</button>
            <button id="testMockEnhancedData" class="button">Test Mock Enhanced Data</button>
            <button id="testMCPDirect" class="button">Test MCP Server Direct</button>
            <button id="generateAI" class="button button-success">Generate AI Ticket</button>
        </div>
    </div>

    <div class="test-section">
        <h3>üìã Test Results</h3>
        <div id="results" class="results">Ready to run tests...\n\nClick "Run Complete Test Suite" to start.</div>
    </div>

    <div class="test-section">
        <h3>üîç Mock Data Preview</h3>
        <div id="mockDataPreview" class="mock-data">Click "Show Mock Data" to display the test data structure.</div>
    </div>

    <script>
        const MCP_SERVER_URL = 'http://localhost:3000';
        let testResults = [];

        // Mock data generator
        function generateMockData() {
            return {
                enhancedFrameData: [
                    {
                        id: "mock-button-1",
                        name: "Primary CTA Button",
                        type: "COMPONENT",
                        description: "Main call-to-action button component",
                        pageName: "Design System",
                        dimensions: { width: 160, height: 48 },
                        position: { x: 100, y: 200 },
                        hierarchy: {
                            layers: [
                                {
                                    id: "btn-bg",
                                    name: "Button Background",
                                    type: "RECTANGLE",
                                    position: { x: 0, y: 0 },
                                    size: { width: 160, height: 48 },
                                    semanticRole: "background"
                                },
                                {
                                    id: "btn-text",
                                    name: "Button Text",
                                    type: "TEXT",
                                    position: { x: 12, y: 16 },
                                    size: { width: 136, height: 16 },
                                    semanticRole: "text"
                                }
                            ],
                            totalDepth: 2,
                            componentCount: 1,
                            textLayerCount: 1
                        },
                        componentInstances: [],
                        designSystemLinks: {
                            buttons: "design-system/buttons",
                            colors: "design-system/colors",
                            typography: "design-system/typography",
                            spacing: "design-system/spacing"
                        },
                        exportScreenshots: [],
                        fileKey: "test-file-123",
                        fileName: "Mock Design System",
                        metadata: {
                            nodeCount: 2,
                            textContent: ["Get Started"],
                            colors: ["#007AFF", "#FFFFFF"],
                            hasPrototype: false,
                            semanticRole: "button",
                            accessibility: {
                                hasLabel: true,
                                role: "button",
                                colorContrast: "AA",
                                focusable: true,
                                issues: []
                            }
                        }
                    }
                ],
                screenshot: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==",
                fileContext: {
                    fileKey: "test-file-123",
                    fileName: "Mock Design System",
                    pageName: "Components",
                    selectionCount: 1
                },
                metadata: {
                    extractedAt: new Date().toISOString(),
                    totalFrames: 1,
                    hasScreenshot: true
                }
            };
        }

        // Logging functions
        function log(message, type = 'info') {
            const results = document.getElementById('results');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'pass' ? '‚úÖ' : type === 'fail' ? '‚ùå' : type === 'warn' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            
            const logMessage = `[${timestamp}] ${prefix} ${message}\n`;
            results.textContent += logMessage;
            results.scrollTop = results.scrollHeight;
            
            testResults.push({ timestamp, type, message });
            console.log(`[Test] ${message}`);
        }

        function clearResults() {
            document.getElementById('results').textContent = 'Results cleared.\n\n';
            testResults = [];
        }

        // Status display function (required by test functions)
        function showStatus(message, type = 'info') {
            log(message, type);
            
            // Also create a temporary status indicator
            const statusDiv = document.createElement('div');
            statusDiv.className = `status status-${type}`;
            statusDiv.textContent = message;
            
            // Insert at top of results
            const results = document.getElementById('results');
            results.insertBefore(statusDiv, results.firstChild);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.remove();
                }
            }, 3000);
        }

        // Error display function (required by test functions)
        function showError(message) {
            showStatus(`‚ùå Error: ${message}`, 'fail');
        }

        // Test functions
        async function testMCPServer() {
            log('Testing MCP Server connection...');
            
            try {
                const response = await fetch(MCP_SERVER_URL, { signal: AbortSignal.timeout(5000) });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                log(`Server connected: ${data.name} v${data.version}`, 'pass');
                log(`Available tools: ${data.tools?.join(', ')}`);
                return true;
            } catch (error) {
                log(`Server connection failed: ${error.message}`, 'fail');
                return false;
            }
        }

        async function testSchemaValidation() {
            log('Testing schema validation...');
            
            const mockData = generateMockData();
            
            // Basic validation checks
            const errors = [];
            const warnings = [];
            
            if (!Array.isArray(mockData.enhancedFrameData)) {
                errors.push('enhancedFrameData must be array');
            }
            
            mockData.enhancedFrameData.forEach((frame, i) => {
                if (!frame.id) errors.push(`Frame ${i}: missing id`);
                if (!frame.dimensions) errors.push(`Frame ${i}: missing dimensions`);
                if (!frame.hierarchy) errors.push(`Frame ${i}: missing hierarchy`);
                if (!frame.metadata) errors.push(`Frame ${i}: missing metadata`);
            });
            
            if (errors.length === 0) {
                log('Schema validation passed', 'pass');
                if (warnings.length > 0) {
                    log(`Warnings: ${warnings.join(', ')}`, 'warn');
                }
                return true;
            } else {
                log(`Schema validation failed: ${errors.join(', ')}`, 'fail');
                return false;
            }
        }

        async function testGemini() {
            showStatus('üß™ Testing Gemini API direct connection...', 'loading');
            log('Testing Gemini API direct connection...');
            
            try {
                // Test through MCP server's Gemini integration
                const response = await fetch(MCP_SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        method: 'generate_ai_ticket',
                        params: {
                            figmaUrl: 'https://figma.com/file/test123/Gemini-Test',
                            techStack: 'React + TypeScript',
                            documentType: 'jira',
                            useAI: true,
                            testMode: true
                        }
                    }),
                    signal: AbortSignal.timeout(10000)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.content && result.content.length > 0) {
                    showStatus('‚úÖ Gemini API test successful via MCP server!', 'pass');
                    log(`Gemini response: ${result.content[0].text?.substring(0, 100)}...`);
                    return true;
                } else if (result.error) {
                    throw new Error(result.error);
                } else {
                    throw new Error('No content in Gemini response');
                }
            } catch (error) {
                showStatus(`‚ùå Gemini API test failed: ${error.message}`, 'fail');
                log(`Gemini error details: ${error.message}`);
                return false;
            }
        }

        async function testAIGeneration() {
            log('Testing AI ticket generation...');
            
            const mockData = generateMockData();
            
            try {
                const response = await fetch(MCP_SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        method: 'generate_ai_ticket',
                        params: {
                            enhancedFrameData: mockData.enhancedFrameData,
                            techStack: 'React + TypeScript',
                            documentType: 'jira',
                            useAI: true
                        }
                    }),
                    signal: AbortSignal.timeout(10000)
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                
                if (result.content?.[0]?.text) {
                    log(`AI generation successful (${result.content[0].text.length} chars)`, 'pass');
                    return true;
                } else {
                    throw new Error('No content in response');
                }
            } catch (error) {
                log(`AI generation failed: ${error.message}`, 'fail');
                return false;
            }
        }

        async function testFullPipeline() {
            log('Testing complete pipeline...');
            
            const tests = [
                { name: 'Server Health', fn: testMCPServer },
                { name: 'Schema Validation', fn: testSchemaValidation },
                { name: 'AI Generation', fn: testAIGeneration }
            ];
            
            let passed = 0;
            
            for (const test of tests) {
                log(`Running: ${test.name}`);
                const result = await test.fn();
                if (result) passed++;
            }
            
            if (passed === tests.length) {
                log('Full pipeline test passed!', 'pass');
                return true;
            } else {
                log(`Pipeline test failed: ${passed}/${tests.length} passed`, 'fail');
                return false;
            }
        }

        async function testTicketGeneration() {
            showStatus('üé´ Testing ticket generation...', 'loading');
            log('üé´ Starting ticket generation test...');
            
            const mockData = generateMockData();
            
            try {
                // Test different ticket generation methods
                const tests = [
                    {
                        name: 'AI Ticket Generation',
                        method: 'generate_ai_ticket',
                        params: {
                            enhancedFrameData: mockData.enhancedFrameData,
                            screenshot: mockData.screenshot,
                            figmaUrl: `https://www.figma.com/file/${mockData.fileContext.fileKey}/${encodeURIComponent(mockData.fileContext.fileName)}`,
                            techStack: 'React + TypeScript',
                            documentType: 'jira',
                            useAI: true
                        }
                    },
                    {
                        name: 'Enhanced Ticket Generation',
                        method: 'generate_enhanced_ticket',
                        params: {
                            figmaUrl: `https://www.figma.com/file/${mockData.fileContext.fileKey}`,
                            selection: 'button-component',
                            techStack: 'React + TypeScript'
                        }
                    },
                    {
                        name: 'Basic Ticket Generation',
                        method: 'generate_tickets',
                        params: {
                            figmaUrl: `https://www.figma.com/file/${mockData.fileContext.fileKey}`,
                            componentName: 'Primary CTA Button'
                        }
                    }
                ];
                
                let successful = 0;
                
                for (const test of tests) {
                    log(`üß™ Testing ${test.name}...`);
                    
                    try {
                        const response = await fetch(MCP_SERVER_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                method: test.method,
                                params: test.params
                            }),
                            signal: AbortSignal.timeout(10000)
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const result = await response.json();
                        
                        if (result.content || result.ticket || result.tickets) {
                            log(`‚úÖ ${test.name} successful`, 'pass');
                            successful++;
                        } else {
                            log(`‚ö†Ô∏è ${test.name} returned unexpected format`, 'warn');
                        }
                        
                    } catch (error) {
                        log(`‚ùå ${test.name} failed: ${error.message}`, 'fail');
                    }
                }
                
                if (successful === tests.length) {
                    showStatus('‚úÖ All ticket generation tests passed!', 'pass');
                    log(`üéâ All ${tests.length} ticket generation methods working`);
                } else if (successful > 0) {
                    showStatus(`‚ö†Ô∏è Partial success: ${successful}/${tests.length} tests passed`, 'warn');
                    log(`üìä ${successful} out of ${tests.length} generation methods working`);
                } else {
                    showStatus('‚ùå All ticket generation tests failed!', 'fail');
                    log('üí• No ticket generation methods are working');
                }
                
                return successful > 0;
                
            } catch (error) {
                showStatus(`‚ùå Ticket generation test failed: ${error.message}`, 'fail');
                log(`üí• Test error: ${error.message}`);
                return false;
            }
        }

        async function testErrorHandling() {
            showStatus('üö® Testing error handling...', 'loading');
            log('üö® Starting error handling test...');
            
            try {
                const errorTests = [
                    {
                        name: 'Invalid URL Test',
                        request: {
                            method: 'generate_ai_ticket',
                            params: {
                                figmaUrl: 'invalid-url',
                                techStack: 'React'
                            }
                        }
                    },
                    {
                        name: 'Missing Parameters Test',
                        request: {
                            method: 'generate_ai_ticket',
                            params: {}
                        }
                    },
                    {
                        name: 'Invalid Method Test',
                        request: {
                            method: 'nonexistent_method',
                            params: {
                                figmaUrl: 'https://figma.com/file/test123'
                            }
                        }
                    },
                    {
                        name: 'Server Timeout Test',
                        request: {
                            method: 'generate_ai_ticket',
                            params: {
                                figmaUrl: 'https://figma.com/file/test123',
                                techStack: 'React'
                            }
                        },
                        timeout: 1 // Very short timeout to force error
                    }
                ];
                
                let errorsCaught = 0;
                
                for (const test of errorTests) {
                    log(`üß™ Testing ${test.name}...`);
                    
                    try {
                        const response = await fetch(MCP_SERVER_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(test.request),
                            signal: AbortSignal.timeout(test.timeout || 5000)
                        });
                        
                        const result = await response.json();
                        
                        if (!response.ok || result.error) {
                            log(`‚úÖ ${test.name} properly handled error`, 'pass');
                            errorsCaught++;
                        } else {
                            log(`‚ö†Ô∏è ${test.name} unexpectedly succeeded`, 'warn');
                        }
                        
                    } catch (error) {
                        log(`‚úÖ ${test.name} caught error: ${error.message}`, 'pass');
                        errorsCaught++;
                    }
                }
                
                if (errorsCaught >= errorTests.length * 0.75) { // At least 75% should catch errors
                    showStatus('‚úÖ Error handling tests passed!', 'pass');
                    log(`üõ°Ô∏è ${errorsCaught}/${errorTests.length} error scenarios handled properly`);
                } else {
                    showStatus(`‚ö†Ô∏è Some error handling issues: ${errorsCaught}/${errorTests.length} passed`, 'warn');
                    log(`üö® Only ${errorsCaught} out of ${errorTests.length} error scenarios handled`);
                }
                
                return errorsCaught > 0;
                
            } catch (error) {
                showStatus(`‚ùå Error handling test failed: ${error.message}`, 'fail');
                log(`üí• Test error: ${error.message}`);
                return false;
            }
        }

        function showMockData() {
            const mockData = generateMockData();
            document.getElementById('mockDataPreview').textContent = JSON.stringify(mockData, null, 2);
            log('Mock data displayed in preview section');
        }

        function testMockData() {
            showStatus('üìä Testing mock data generation...', 'loading');
            log('üìä Starting mock data generation test...');
            
            try {
                const mockData = generateMockData();
                
                // Basic checks
                if (!mockData) {
                    throw new Error('No mock data generated');
                }
                
                log(`‚úÖ Mock data generated successfully`);
                log(`üìã Data structure: ${Object.keys(mockData).join(', ')}`);
                log(`üéØ Enhanced frames: ${mockData.enhancedFrameData?.length || 0}`);
                log(`üì∏ Screenshot: ${mockData.screenshot ? 'included' : 'missing'}`);
                log(`üìÅ File context: ${mockData.fileContext ? 'included' : 'missing'}`);
                
                // Update the preview
                document.getElementById('mockDataPreview').textContent = JSON.stringify(mockData, null, 2);
                
                showStatus('‚úÖ Mock data generation successful!', 'pass');
                return true;
                
            } catch (error) {
                showStatus(`‚ùå Mock data generation failed: ${error.message}`, 'fail');
                log(`‚ùå Error: ${error.message}`);
                return false;
            }
        }

        // Additional test functions that mirror the main UI
        async function testMockAIGeneration() {
            showStatus('üß™ Testing AI generation with mock data...', 'loading');
            
            const mockData = generateMockData();
            
            try {
                const response = await fetch(MCP_SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        method: 'generate_ai_ticket',
                        params: {
                            enhancedFrameData: mockData.enhancedFrameData,
                            screenshot: mockData.screenshot,
                            techStack: 'React + TypeScript',
                            documentType: 'jira',
                            useAI: true
                        }
                    }),
                    signal: AbortSignal.timeout(10000)
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                
                if (result.content?.[0]?.text) {
                    showStatus('‚úÖ Mock AI generation completed successfully!', 'pass');
                    log(`Generated content: ${result.content[0].text.length} characters`);
                    return true;
                } else {
                    throw new Error('No content in response');
                }
            } catch (error) {
                showStatus(`‚ùå Mock AI generation failed: ${error.message}`, 'fail');
                return false;
            }
        }

        function testMockEnhancedData() {
            showStatus('üß™ Testing enhanced data structure...', 'loading');
            log('üß™ Starting enhanced data structure test...');
            
            const mockData = generateMockData();
            log(`üìä Generated mock data with ${mockData.enhancedFrameData.length} frames`);
            
            // Validate enhanced data structure
            const errors = [];
            
            if (!Array.isArray(mockData.enhancedFrameData)) {
                errors.push('enhancedFrameData must be array');
            }
            
            mockData.enhancedFrameData.forEach((frame, i) => {
                log(`üîç Validating frame ${i + 1}: ${frame.name || frame.id}`);
                if (!frame.id) errors.push(`Frame ${i}: missing id`);
                if (!frame.dimensions) errors.push(`Frame ${i}: missing dimensions`);
                if (!frame.hierarchy) errors.push(`Frame ${i}: missing hierarchy`);
                if (!frame.metadata) errors.push(`Frame ${i}: missing metadata`);
            });
            
            // Validate file context
            if (mockData.fileContext) {
                log(`üìÅ File context: ${mockData.fileContext.fileName} (${mockData.fileContext.fileKey})`);
            }
            
            // Validate screenshot
            if (mockData.screenshot) {
                log(`üì∏ Screenshot data: ${mockData.screenshot.length} characters`);
            }
            
            if (errors.length === 0) {
                showStatus('‚úÖ Enhanced data structure validation passed!', 'pass');
                log(`‚úÖ Validated ${mockData.enhancedFrameData.length} frame(s) successfully`);
                log(`üìã Data includes: hierarchy, metadata, file context, screenshot`);
            } else {
                showStatus(`‚ùå Enhanced data validation failed: ${errors.join(', ')}`, 'fail');
                log(`‚ùå Validation errors: ${errors.join(', ')}`);
            }
        }

        async function testMCPServerDirect() {
            showStatus('üîß Testing MCP server direct connection...', 'loading');
            
            try {
                // Test server health
                const response = await fetch(MCP_SERVER_URL, { signal: AbortSignal.timeout(5000) });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                showStatus(`‚úÖ MCP server connected: ${data.name} v${data.version}`, 'pass');
                log(`Available tools: ${data.tools?.join(', ')}`);
                
                // Test a simple tool call
                const testCall = await fetch(MCP_SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        method: 'check_compliance',
                        params: {
                            figmaUrl: 'https://figma.com/file/test123',
                            categories: ['color', 'typography']
                        }
                    }),
                    signal: AbortSignal.timeout(10000)
                });
                
                if (testCall.ok) {
                    showStatus('‚úÖ MCP tool call test passed!', 'pass');
                } else {
                    throw new Error(`Tool call failed: ${testCall.status}`);
                }
                
                return true;
            } catch (error) {
                showStatus(`‚ùå MCP server test failed: ${error.message}`, 'fail');
                return false;
            }
        }

        // AI ticket generation function that mirrors the main UI
        async function generateAITicket() {
            showStatus('ü§ñ Starting AI ticket generation...', 'loading');
            log('ü§ñ Starting AI ticket generation with mock data...');
            
            const mockData = generateMockData();
            log(`üìä Using mock data: ${mockData.enhancedFrameData.length} frames`);
            
            try {
                log('üì§ Sending request to MCP server...');
                const requestData = {
                    method: 'generate_ai_ticket',
                    params: {
                        enhancedFrameData: mockData.enhancedFrameData,
                        screenshot: mockData.screenshot,
                        figmaUrl: `https://www.figma.com/file/${mockData.fileContext.fileKey}/${encodeURIComponent(mockData.fileContext.fileName)}`,
                        techStack: 'React + TypeScript',
                        documentType: 'jira',
                        projectName: mockData.fileContext.fileName,
                        fileContext: mockData.fileContext,
                        metadata: mockData.metadata,
                        useAI: true
                    }
                };
                
                log(`üîó Request URL: ${MCP_SERVER_URL}`);
                log(`üìã Request params: ${JSON.stringify(requestData.params, null, 2).substring(0, 200)}...`);
                
                const response = await fetch(MCP_SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData),
                    signal: AbortSignal.timeout(15000)
                });
                
                log(`üì° Response status: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const result = await response.json();
                log(`üì¶ Response received: ${JSON.stringify(result).substring(0, 100)}...`);
                
                let generatedContent = '';
                if (result.content && Array.isArray(result.content)) {
                    generatedContent = result.content
                        .filter(item => item.type === 'text')
                        .map(item => typeof item.text === 'string' ? item.text : JSON.stringify(item.text))
                        .join('\n\n');
                    log(`‚úÖ Extracted content: ${generatedContent.length} characters`);
                } else if (result.ticket) {
                    generatedContent = typeof result.ticket === 'string' ? result.ticket : JSON.stringify(result.ticket);
                    log(`‚úÖ Extracted ticket: ${generatedContent.length} characters`);
                } else {
                    generatedContent = JSON.stringify(result, null, 2);
                    log(`‚ö†Ô∏è Using raw response: ${generatedContent.length} characters`);
                }
                
                // Display the result
                let resultsContainer = document.getElementById('generatedTicketResults');
                if (!resultsContainer) {
                    resultsContainer = document.createElement('div');
                    resultsContainer.id = 'generatedTicketResults';
                    resultsContainer.style.marginTop = '16px';
                    document.getElementById('results').parentNode.appendChild(resultsContainer);
                }
                
                resultsContainer.innerHTML = `
                    <h4>üé´ Generated AI Ticket:</h4>
                    <textarea style="width: 100%; height: 300px; font-family: monospace; font-size: 12px; border: 1px solid #ccc; border-radius: 4px; padding: 8px;">${generatedContent}</textarea>
                `;
                
                showStatus('‚úÖ AI ticket generated successfully!', 'pass');
                log(`‚úÖ AI ticket generation completed: ${generatedContent.length} characters`);
                
            } catch (error) {
                showStatus(`‚ùå AI ticket generation failed: ${error.message}`, 'fail');
                log(`‚ùå Generation error: ${error.message}`);
                log(`üîç Error details: ${error.stack}`);
            }
        }

        async function runCompleteTestSuite() {
            log('üöÄ Starting Complete Test Suite');
            log('='.repeat(50));
            
            const startTime = Date.now();
            
            await testFullPipeline();
            
            const duration = Date.now() - startTime;
            log('='.repeat(50));
            log(`Test suite completed in ${duration}ms`);
        }

        // Event listeners
        document.getElementById('runAll').addEventListener('click', runCompleteTestSuite);
        document.getElementById('clearResults').addEventListener('click', clearResults);
        document.getElementById('testServer').addEventListener('click', testMCPServer);
        document.getElementById('testAI').addEventListener('click', testAIGeneration);
        document.getElementById('testGemini').addEventListener('click', testGemini);
        document.getElementById('testValidation').addEventListener('click', testSchemaValidation);
        document.getElementById('testMockData').addEventListener('click', testMockData);
        document.getElementById('testFullPipeline').addEventListener('click', testFullPipeline);
        document.getElementById('testTicketGeneration').addEventListener('click', testTicketGeneration);
        document.getElementById('testErrorHandling').addEventListener('click', testErrorHandling);
        document.getElementById('showMockData').addEventListener('click', showMockData);

        // Additional event listeners that might be called from injected code
        if (document.getElementById('testMockAI')) {
            document.getElementById('testMockAI').addEventListener('click', testMockAIGeneration);
        }
        if (document.getElementById('testMockEnhancedData')) {
            document.getElementById('testMockEnhancedData').addEventListener('click', testMockEnhancedData);
        }
        if (document.getElementById('testMCPDirect')) {
            document.getElementById('testMCPDirect').addEventListener('click', testMCPServerDirect);
        }
        if (document.getElementById('generateAI')) {
            document.getElementById('generateAI').addEventListener('click', generateAITicket);
        }

        // Initialize
        log('üß™ Standalone testing suite loaded');
        log('Ready to test MCP data layer without Figma dependency');
    </script>
</body>
</html>