<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>AI Ticket Generator</title>
  <style>
/**
 * Main CSS Styles for Figma AI Ticket Generator
 */

* {
  box-sizing: border-box;
}

/* Main Layout - 50/50 Split */
.main-container {
  display: flex;
  gap: 24px;
  min-height: calc(100vh - 100px); /* Adjusted for tab header */
}

.panel {
  flex: 1;
}

.panel-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--figma-color-border);
}

.panel-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--figma-color-text);
  margin: 0;
}

.panel-subtitle {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  margin: 4px 0 0 0;
}

/* Health Metrics Panel Styles */
.health-panel {
  background: var(--figma-color-bg);
  border-right: 1px solid var(--figma-color-border);
  padding-right: 20px;
}

.metric-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 20px;
}

@media (max-width: 600px) {
  .metric-grid {
    grid-template-columns: 1fr;
    gap: 8px;
  }
}

.metric-card {
  background: var(--figma-color-bg-secondary);
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  padding: 16px;
  text-align: center;
}

.metric-value {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 4px;
}

.metric-value.excellent { color: #0d9f3c; }
.metric-value.good { color: #f4a113; }
.metric-value.needs-attention { color: #e34f47; }

.metric-label {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.detailed-metrics {
  margin-bottom: 20px;
}

.section-title {
  font-size: 12px;
  font-weight: 600;
  margin-bottom: 12px;
  color: var(--figma-color-text);
}

.metric-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid var(--figma-color-border-subtle);
}

.metric-name {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
}

.metric-score {
  font-size: 12px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 3px;
}

.metric-score.high {
  background: var(--figma-color-bg-success-tertiary);
  color: var(--figma-color-text-success);
}

.metric-score.medium {
  background: var(--figma-color-bg-warning-tertiary);
  color: var(--figma-color-text-warning);
}

.metric-score.low {
  background: var(--figma-color-bg-danger-tertiary);
  color: var(--figma-color-text-danger);
}

/* Ticket Panel Styles */
.ticket-panel {
  background: var(--figma-color-bg);
  padding-left: 20px;
}

/* Compliance Analysis Styles */
.analysis-summary {
  margin-bottom: 12px;
  padding: 8px;
  background: var(--figma-color-bg-secondary);
  border-radius: 4px;
}

.summary-stat {
  display: flex;
  justify-content: space-between;
}

.stat-label {
  color: var(--figma-color-text-secondary);
  font-size: 11px;
}

.stat-value {
  font-weight: 600;
  color: var(--figma-color-text);
}

.breakdown-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 12px;
}

.breakdown-item {
  padding: 8px;
  background: var(--figma-color-bg-secondary);
  border-radius: 4px;
  text-align: center;
}

.breakdown-label {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  margin-bottom: 4px;
}

.breakdown-score {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 2px;
}

.breakdown-score.excellent {
  color: var(--figma-color-text-success);
}

.breakdown-score.good {
  color: var(--figma-color-text-success);
}

.breakdown-score.medium {
  color: var(--figma-color-text-warning);
}

.breakdown-score.needs-attention {
  color: var(--figma-color-text-warning);
}

.breakdown-score.poor {
  color: var(--figma-color-text-danger);
}

.breakdown-details {
  font-size: 10px;
  color: var(--figma-color-text-tertiary);
}

/* Recommendation Styles */
.recommendation-item {
  padding: 8px;
  margin-bottom: 8px;
  border-radius: 4px;
  border-left: 3px solid;
}

.recommendation-item.high {
  background: var(--figma-color-bg-danger-tertiary);
  border-color: var(--figma-color-border-danger);
}

.recommendation-item.medium {
  background: var(--figma-color-bg-warning-tertiary);
  border-color: var(--figma-color-border-warning);
}

.recommendation-item.low {
  background: var(--figma-color-bg-secondary);
  border-color: var(--figma-color-border);
}

.rec-priority {
  font-size: 9px;
  font-weight: 600;
  color: var(--figma-color-text-secondary);
  margin-bottom: 2px;
}

.rec-category {
  font-size: 11px;
  font-weight: 600;
  color: var(--figma-color-text);
  margin-bottom: 4px;
}

.rec-description {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  margin-bottom: 4px;
}

.rec-action {
  font-size: 10px;
  color: var(--figma-color-text);
  font-style: italic;
}

.placeholder-text.error {
  color: var(--figma-color-text-danger);
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  margin: 0;
  padding: 20px;
  background-color: var(--figma-color-bg);
  color: var(--figma-color-text);
  font-size: 12px;
  line-height: 1.4;
}

.header {
  margin-bottom: 20px;
  text-align: center;
}

.title {
  font-size: 16px;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: var(--figma-color-text);
}

.subtitle {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  margin: 0;
}

.config-section {
  margin-bottom: 16px;
  padding: 12px;
  background: var(--figma-color-bg-secondary);
  border-radius: 6px;
}

.config-title {
  font-size: 12px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--figma-color-text);
}

.form-group {
  margin-bottom: 12px;
}

.form-group:last-child {
  margin-bottom: 0;
}

label {
  display: block;
  font-size: 11px;
  font-weight: 500;
  margin-bottom: 4px;
  color: var(--figma-color-text);
}

input, select, textarea {
  width: 100%;
  padding: 6px 8px;
  border: 1px solid var(--figma-color-border);
  border-radius: 4px;
  font-size: 11px;
  background: var(--figma-color-bg);
  color: var(--figma-color-text);
  resize: vertical;
}

input:focus, select:focus, textarea:focus {
  outline: none;
  border-color: var(--figma-color-border-selected);
  box-shadow: 0 0 0 1px var(--figma-color-border-selected);
}

input[type="password"] {
  font-family: monospace;
}

.button {
  width: 100%;
  padding: 8px 12px;
  border: none;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  background: var(--figma-color-bg-brand);
  color: var(--figma-color-text-onbrand);
  transition: background-color 0.2s ease;
}

.button:hover:not(:disabled) {
  background: var(--figma-color-bg-brand-hover);
}

.button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.button.button-secondary {
  background: var(--figma-color-bg);
  color: var(--figma-color-text);
  border: 1px solid var(--figma-color-border);
}

.button.button-secondary:hover:not(:disabled) {
  background: var(--figma-color-bg-hover);
}

.output-section {
  margin-top: 16px;
}

.output-section textarea {
  min-height: 200px;
  font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
  font-size: 10px;
  line-height: 1.5;
}

.status {
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 11px;
  margin-bottom: 12px;
  text-align: center;
}

.status.loading {
  background: var(--figma-color-bg-secondary);
  color: var(--figma-color-text-secondary);
}

.status.success {
  background: var(--figma-color-bg-success);
  color: var(--figma-color-text-onsuccess);
}

.status.error {
  background: var(--figma-color-bg-danger);
  color: var(--figma-color-text-ondanger);
}

.hidden {
  display: none !important;
}

.template-select {
  border-bottom: 1px solid var(--figma-color-border);
  padding-bottom: 8px;
  margin-bottom: 8px;
}

/* Template Preview */
.template-preview {
  background: var(--figma-color-bg-secondary);
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  padding: 12px;
  margin-top: 16px;
}

.preview-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--figma-color-text);
  margin-bottom: 8px;
}

.preview-content {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  line-height: 1.4;
  white-space: pre-line;
}

.preview-content.loaded {
  color: var(--figma-color-text);
}

/* Priority and story points styling */
#priority option {
  padding: 4px;
}

#storyPoints {
  color: var(--figma-color-text);
}

#labels {
  font-family: monospace;
  font-size: 11px;
}

/* Format help text */
.format-help {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  margin-top: 4px;
  padding: 4px 8px;
  background: var(--figma-color-bg-secondary);
  border-radius: 4px;
  border-left: 3px solid var(--figma-color-border);
}

/* Status messages */
.status-message {
  padding: 8px 12px;
  border-radius: 4px;
  margin-bottom: 12px;
  font-size: 11px;
  font-weight: 500;
  display: none;
}

.status-message.loading {
  background: var(--figma-color-bg-secondary);
  color: var(--figma-color-text);
  border: 1px solid var(--figma-color-border);
  display: block;
  position: relative;
  overflow: hidden;
}

/* Enhanced Progress Indicators */
.progress-container {
  margin-top: 8px;
  margin-bottom: 8px;
}

.progress-bar {
  width: 100%;
  height: 4px;
  background: var(--figma-color-bg-tertiary);
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--figma-color-bg-brand);
  border-radius: 2px;
  transition: width 0.3s ease;
  width: 0%;
}

.progress-steps {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 6px;
  font-size: 11px;
  color: var(--figma-color-text-secondary);
}

.progress-step {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
}

.progress-step.active {
  color: var(--figma-color-text-brand);
  font-weight: 500;
}

.progress-step.completed {
  color: var(--figma-color-text-success);
}

.progress-step.error {
  color: var(--figma-color-text-danger);
}

.step-indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 2px solid currentColor;
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
}

.step-indicator.completed {
  background: currentColor;
  color: white;
}

.step-indicator.active {
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.7; }
  100% { transform: scale(1); opacity: 1; }
}

/* Loading spinner for active operations */
.loading-spinner {
  width: 12px;
  height: 12px;
  border: 2px solid var(--figma-color-border);
  border-top: 2px solid var(--figma-color-bg-brand);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  display: inline-block;
  margin-right: 6px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Time indicator */
.time-indicator {
  font-size: 10px;
  color: var(--figma-color-text-tertiary);
  margin-left: 8px;
}

/* Detailed progress info */
.progress-details {
  margin-top: 6px;
  padding: 6px 8px;
  background: var(--figma-color-bg-tertiary);
  border-radius: 3px;
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  display: none;
}

.progress-details.visible {
  display: block;
}

.status-message.success {
  background: #e7f5e7;
  color: #2d5a2d;
  border: 1px solid #5cb85c;
  display: block;
}

.status-message.error {
  background: #f8e7e7;
  color: #722d2d;
  border: 1px solid #d9534f;
  display: block;
}

.status-message.warning {
  background: #fff3cd;
  color: #856404;
  border: 1px solid #ffeaa7;
  display: block;
}

/* Retry button for error scenarios */
.retry-button {
  background: var(--figma-color-bg-brand);
  color: var(--figma-color-text-onbrand);
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  margin-top: 8px;
  font-size: 12px;
  font-weight: 500;
}

.retry-button:hover {
  background: var(--figma-color-bg-brand-hover);
}

.retry-button:active {
  background: var(--figma-color-bg-brand-pressed);
}

/* Frame info display */
.frame-info {
  background: var(--figma-color-bg-secondary);
  border-radius: 4px;
  padding: 8px;
  margin-bottom: 12px;
  font-size: 10px;
}

.frame-item {
  margin-bottom: 8px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--figma-color-border);
}

.frame-item:last-child {
  margin-bottom: 0;
  padding-bottom: 0;
  border-bottom: none;
}

.frame-name {
  font-weight: 600;
  color: var(--figma-color-text);
  margin-bottom: 4px;
}

.frame-details {
  color: var(--figma-color-text-secondary);
  line-height: 1.3;
}

/* Design System Styles */
.design-system-detected {
  background: linear-gradient(135deg, var(--figma-color-bg-success-tertiary), var(--figma-color-bg-brand-tertiary));
  border: 1px solid var(--figma-color-border-success);
  border-radius: 6px;
  padding: 12px;
  margin-bottom: 12px;
}

.ds-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.ds-name {
  font-weight: 600;
  color: var(--figma-color-text);
  font-size: 13px;
}

.ds-confidence {
  background: var(--figma-color-bg-success);
  color: var(--figma-color-text-onbrand);
  padding: 2px 6px;
  border-radius: 12px;
  font-size: 10px;
  font-weight: 500;
}

.ds-stats {
  display: flex;
  gap: 12px;
}

.ds-stat {
  color: var(--figma-color-text-secondary);
  font-size: 11px;
}

.compliance-info {
  background: var(--figma-color-bg-tertiary);
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  padding: 12px;
  margin-top: 8px;
}

.compliance-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.compliance-title {
  font-weight: 600;
  font-size: 12px;
}

.compliance-score {
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  color: white;
}

.compliance-breakdown {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 8px;
  margin-bottom: 12px;
}

.compliance-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px;
  background: var(--figma-color-bg);
  border-radius: 4px;
  border: 1px solid var(--figma-color-border);
}

.item-label {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  margin-bottom: 2px;
}

.item-score {
  font-size: 12px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 8px;
  color: white;
}

.recommendations {
  border-top: 1px solid var(--figma-color-border);
  padding-top: 12px;
}

.rec-title {
  font-weight: 600;
  font-size: 11px;
  margin-bottom: 8px;
  color: var(--figma-color-text);
}

.rec-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.rec-item {
  padding: 8px;
  border-radius: 4px;
  border-left: 3px solid;
}

.rec-item.high {
  background: var(--figma-color-bg-danger-tertiary);
  border-left-color: var(--figma-color-bg-danger);
}

.rec-item.medium {
  background: var(--figma-color-bg-warning-tertiary);
  border-left-color: var(--figma-color-bg-warning);
}

.rec-item.low {
  background: var(--figma-color-bg-success-tertiary);
  border-left-color: var(--figma-color-bg-success);
}

.rec-message {
  font-size: 11px;
  font-weight: 500;
  margin-bottom: 2px;
  color: var(--figma-color-text);
}

.rec-suggestion {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
}

/* Tab System Styles */
.tab-container {
  width: 100%;
}

.tab-header {
  display: flex;
  border-bottom: 1px solid var(--figma-color-border);
  margin-bottom: 20px;
  background: var(--figma-color-bg-secondary);
  border-radius: 6px 6px 0 0;
}

.tab-button {
  flex: 1;
  padding: 12px 16px;
  border: none;
  background: transparent;
  color: var(--figma-color-text-secondary);
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.tab-button:first-child {
  border-radius: 6px 0 0 0;
}

.tab-button:last-child {
  border-radius: 0 6px 0 0;
}

.tab-button:hover {
  background: var(--figma-color-bg-hover);
  color: var(--figma-color-text);
}

.tab-button.active {
  background: var(--figma-color-bg);
  color: var(--figma-color-text);
  border-bottom-color: var(--figma-color-border-brand);
  font-weight: 600;
}

.tab-content {
  display: none;
  animation: fadeIn 0.3s ease;
}

.tab-content.active {
  display: block;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Adjust main container for single tab view */
.tab-content .panel {
  width: 100%;
  margin: 0 auto;
}

.tab-content .main-container {
  display: block; /* Stack vertically in tab view */
  gap: 0;
}

/* Remove side-by-side layout styles when in tab view */
.health-panel {
  border-right: none;
  padding-right: 0;
}

.ticket-panel {
  padding-left: 0;
}
  </style>
</head>
<body>
  <div class="tab-container">
    <!-- Tab Header -->
    <div class="tab-header">
      <button class="tab-button active" data-tab="health">
        📊 Design System Health
      </button>
      <button class="tab-button" data-tab="ticket">
        🎫 Ticket Generator
      </button>
    </div>

    <!-- Health Metrics Tab Content -->
    <div id="health-tab" class="tab-content active">
      <div class="main-container">
        <div class="panel health-panel">
          <div class="panel-header">
            <h2 class="panel-title">📊 Design System Health</h2>
          </div>
          <p class="panel-subtitle">Real-time compliance and usage metrics</p>
          
          <!-- Overall Health Score -->
          <div class="metric-grid">
            <div class="metric-card">
              <div class="metric-value excellent" id="overallScore">--</div>
              <div class="metric-label">Overall Score</div>
            </div>
            <div class="metric-card">
              <div class="metric-value good" id="complianceRate">--</div>
              <div class="metric-label">Compliance Rate</div>
            </div>
            <div class="metric-card">
              <div class="metric-value good" id="componentUsage">--</div>
              <div class="metric-label">Component Usage</div>
            </div>
            <div class="metric-card">
              <div class="metric-value needs-attention" id="tokenAdoption">--</div>
              <div class="metric-label">Token Adoption</div>
            </div>
          </div>
          
          <!-- Detailed Metrics -->
          <div class="detailed-metrics">
            <div class="section-title">Component Analysis</div>
            <div class="metric-row">
              <span class="metric-name">Standard Components</span>
              <span class="metric-score high" id="standardComponents">--</span>
            </div>
            <div class="metric-row">
              <span class="metric-name">Custom Components</span>
              <span class="metric-score medium" id="customComponents">--</span>
            </div>
            <div class="metric-row">
              <span class="metric-name">Most Used Component</span>
              <span class="metric-score high" id="topComponent">--</span>
            </div>
          </div>
          
          <div class="detailed-metrics">
            <div class="section-title">Token Adoption</div>
            <div class="metric-row">
              <span class="metric-name">Color Tokens</span>
              <span class="metric-score high" id="colorTokens">--</span>
            </div>
            <div class="metric-row">
              <span class="metric-name">Typography Tokens</span>
              <span class="metric-score medium" id="typographyTokens">--</span>
            </div>
            <div class="metric-row">
              <span class="metric-name">Spacing Tokens</span>
              <span class="metric-score low" id="spacingTokens">--</span>
            </div>
          </div>
          
          <!-- Health Recommendations -->
          <div class="detailed-metrics">
            <div class="section-title">Recommendations</div>
            <div id="healthRecommendations">
              <div class="metric-row">
                <span class="metric-name">Loading health data...</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Ticket Generator Tab Content -->
    <div id="ticket-tab" class="tab-content">
      <div class="main-container">
        <div class="panel ticket-panel">
          <div class="panel-header">
            <h2 class="panel-title">🎫 AI Ticket Generator</h2>
          </div>
          <p class="panel-subtitle">Generate Jira tickets from selected Figma frames</p>

      <div class="config-section">
        <div class="config-title">AI Configuration</div>
        
        <div class="form-group">
          <label for="apiKey">OpenAI API Key</label>
          <input type="password" id="apiKey" placeholder="sk-..." />
        </div>
        
        <div class="form-group">
          <label for="model">Model</label>
          <select id="model">
            <option value="gpt-4o-mini">GPT-4o Mini (Recommended)</option>
            <option value="gpt-4o">GPT-4o</option>
            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
          </select>
        </div>
      </div>

      <div class="config-section">
        <div class="config-title">Ticket Template</div>
        
        <div class="form-group template-select">
          <label for="template">Template Type</label>
          <select id="template">
            <option value="story">User Story</option>
            <option value="task">Technical Task</option>
            <option value="component">UI Component</option>
            <option value="feature">Feature Implementation</option>
            <option value="bug">Bug Fix</option>
            <option value="epic">Epic</option>
            <option value="improvement">Improvement</option>
            <option value="research">Design Research</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="priority">Priority Level</label>
          <select id="priority">
            <option value="highest">🔴 Highest</option>
            <option value="high">🟠 High</option>
            <option value="medium" selected>🟡 Medium</option>
            <option value="low">🟢 Low</option>
            <option value="lowest">🔵 Lowest</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="storyPoints">Story Points (Optional)</label>
          <select id="storyPoints">
            <option value="">Not Set</option>
            <option value="1">1 - Trivial</option>
            <option value="2">2 - Minor</option>
            <option value="3">3 - Simple</option>
            <option value="5">5 - Medium</option>
            <option value="8">8 - Complex</option>
            <option value="13">13 - Large</option>
            <option value="21">21 - Huge</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="outputFormat">Output Format</label>
          <select id="outputFormat">
            <option value="jira-wiki">Jira Wiki Markup (Recommended)</option>
            <option value="plain-text">Plain Text (Universal)</option>
            <option value="markdown">Markdown (GitHub/Modern Tools)</option>
            <option value="confluence">Confluence Format</option>
          </select>
          <div class="format-help" id="formatHelp">
            Jira Wiki Markup: Uses *bold*, bullet points, and formatting that works in most Jira instances
          </div>
        </div>
        
        <div class="form-group">
          <label for="labels">Labels (comma-separated)</label>
          <input type="text" id="labels" placeholder="frontend, design-system, accessibility" />
        </div>
        
        <div class="form-group">
          <label for="customPrompt">Additional Instructions (Optional)</label>
          <textarea id="customPrompt" rows="3" placeholder="e.g., Include accessibility requirements, use specific design tokens, follow WCAG guidelines..."></textarea>
        </div>
        
        <!-- Template Preview -->
        <div class="template-preview" id="templatePreview">
          <div class="preview-title">Template Preview:</div>
          <div class="preview-content" id="previewContent">
            Select a template to see the structure
          </div>
        </div>
      </div>

      <!-- Design System Integration for Tickets -->
      <div id="designSystemSection" class="config-section hidden">
        <div class="config-title">🎨 Design System Integration</div>
        
        <div id="designSystemInfo">
          <div class="design-system-detected">
            <div class="ds-header">
              <span class="ds-name" id="dsName">Design System Detected</span>
              <span class="ds-confidence" id="dsConfidence">85%</span>
            </div>
            <div class="ds-stats">
              <span class="ds-stat" id="dsColors">12 colors</span>
              <span class="ds-stat" id="dsTypography">8 text styles</span>
              <span class="ds-stat" id="dsComponents">24 components</span>
            </div>
          </div>
        </div>

        <div id="complianceInfo" class="compliance-info hidden">
          <div class="compliance-header">
            <span class="compliance-title">Compliance Analysis</span>
            <span class="compliance-score" id="complianceScore">92%</span>
          </div>
          <div class="compliance-breakdown">
            <div class="compliance-item">
              <span class="item-label">Colors:</span>
              <span class="item-score" id="colorScore">95%</span>
            </div>
            <div class="compliance-item">
              <span class="item-label">Typography:</span>
              <span class="item-score" id="typographyScore">88%</span>
            </div>
            <div class="compliance-item">
              <span class="item-label">Components:</span>
              <span class="item-score" id="componentScore">94%</span>
            </div>
          </div>
          
          <div id="recommendations" class="recommendations hidden">
            <div class="rec-title">Recommendations:</div>
            <div id="recList" class="rec-list"></div>
          </div>
        </div>
      </div>

      <div id="frameInfo" class="hidden"></div>
      <div id="status" class="hidden"></div>

      <button id="generate" class="button">
        📋 Generate Ticket from Selection
      </button>

      <div class="output-section">
        <label for="output">Generated Ticket</label>
        <textarea id="output" placeholder="Select frames in Figma and click 'Generate Ticket' to create a Jira ticket draft..."></textarea>
        
        <button id="copy" class="button button-secondary" disabled>
          📋 Copy to Clipboard
        </button>
      </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Inline all JavaScript for Figma compatibility -->
  <script>
    console.log('🔧 Starting inline JavaScript...');
    
    // ==========================================
    // TIMEOUT UTILITIES
    // ==========================================
    
    class TimeoutError extends Error {
      constructor(message) {
        super(message);
        this.name = 'TimeoutError';
      }
    }
    
    class ValidationError extends Error {
      constructor(message) {
        super(message);
        this.name = 'ValidationError';
      }
    }
    
    class APIError extends Error {
      constructor(message, status, endpoint) {
        super(message);
        this.name = 'APIError';
        this.status = status;
        this.endpoint = endpoint;
      }
    }
    
    class NetworkError extends Error {
      constructor(message) {
        super(message);
        this.name = 'NetworkError';
      }
    }
    
    // ==========================================
    // COMPREHENSIVE ERROR HANDLING
    // ==========================================
    
    const ERROR_MESSAGES = {
      // API Key related
      MISSING_API_KEY: 'Please enter your OpenAI API key in the settings.',
      INVALID_API_KEY: 'Invalid API key. Please check your OpenAI API key and try again.',
      API_KEY_QUOTA: 'API key quota exceeded. Please check your OpenAI billing and usage limits.',
      
      // Network related
      NETWORK_TIMEOUT: 'Request timed out. The API may be experiencing high load. Please try again in a few moments.',
      NETWORK_ERROR: 'Network error. Please check your internet connection and try again.',
      CONNECTION_FAILED: 'Failed to connect to OpenAI API. Please check your internet connection.',
      
      // Figma related
      NO_SELECTION: 'Please select at least one frame, component, or instance to generate a ticket.',
      INVALID_SELECTION: 'Selected elements are not suitable for ticket generation. Please select frames, components, or instances.',
      FIGMA_ACCESS_ERROR: 'Unable to access Figma elements. Please try refreshing the plugin.',
      FRAME_READ_ERROR: 'Error reading frame data. The selection may contain unsupported elements.',
      
      // API Response related
      MODEL_NOT_FOUND: 'The selected AI model is not available. Please try a different model.',
      CONTENT_FILTER: 'Content was filtered by OpenAI. Please review your selection and try again.',
      RATE_LIMIT: 'API rate limit exceeded. Please wait a moment before trying again.',
      SERVER_ERROR: 'OpenAI server error. Please try again in a few minutes.',
      
      // Validation related
      EMPTY_RESPONSE: 'Received empty response from AI. Please try again with a different selection.',
      INVALID_TEMPLATE: 'Invalid ticket template selected. Please choose a valid template.',
      PARSING_ERROR: 'Error processing AI response. The generated content may be incomplete.',
      
      // General
      UNKNOWN_ERROR: 'An unexpected error occurred. Please try again or contact support.',
      CLIPBOARD_ERROR: 'Could not copy to clipboard. Please manually select and copy the text.',
      
      // Retry suggestions
      RETRY_SUGGESTION: 'If the problem persists, try:\n• Selecting fewer elements\n• Using a simpler template\n• Checking your internet connection'
    };
    
    function createComprehensiveErrorMessage(error, context = '') {
      let primaryMessage = '';
      let secondaryMessage = '';
      let suggestions = [];
      
      // Determine primary error type and message
      if (error instanceof TimeoutError) {
        primaryMessage = ERROR_MESSAGES.NETWORK_TIMEOUT;
        suggestions.push('Try selecting fewer elements', 'Check your internet connection');
      } else if (error instanceof NetworkError || error.name === 'NetworkError') {
        primaryMessage = ERROR_MESSAGES.NETWORK_ERROR;
        suggestions.push('Check your internet connection', 'Try again in a few moments');
      } else if (error instanceof ValidationError) {
        primaryMessage = error.message;
        suggestions.push('Review your selection', 'Check your inputs');
      } else if (error instanceof APIError) {
        switch (error.status) {
          case 401:
            primaryMessage = ERROR_MESSAGES.INVALID_API_KEY;
            suggestions.push('Verify your API key in settings');
            break;
          case 429:
            primaryMessage = ERROR_MESSAGES.RATE_LIMIT;
            suggestions.push('Wait 1-2 minutes before trying again');
            break;
          case 404:
            primaryMessage = ERROR_MESSAGES.MODEL_NOT_FOUND;
            suggestions.push('Try a different AI model');
            break;
          case 500:
          case 502:
          case 503:
            primaryMessage = ERROR_MESSAGES.SERVER_ERROR;
            suggestions.push('Try again in a few minutes');
            break;
          default:
            primaryMessage = `API Error (${error.status}): ${error.message}`;
        }
      } else {
        // Parse specific error messages
        const errorMsg = error.message || error.toString();
        
        if (errorMsg.includes('API key') || errorMsg.includes('Unauthorized')) {
          primaryMessage = ERROR_MESSAGES.INVALID_API_KEY;
          suggestions.push('Check your API key in settings');
        } else if (errorMsg.includes('quota') || errorMsg.includes('billing')) {
          primaryMessage = ERROR_MESSAGES.API_KEY_QUOTA;
          suggestions.push('Check your OpenAI billing dashboard');
        } else if (errorMsg.includes('rate limit') || errorMsg.includes('Too Many Requests')) {
          primaryMessage = ERROR_MESSAGES.RATE_LIMIT;
          suggestions.push('Wait before trying again');
        } else if (errorMsg.includes('model') && errorMsg.includes('not found')) {
          primaryMessage = ERROR_MESSAGES.MODEL_NOT_FOUND;
          suggestions.push('Select a different AI model');
        } else if (errorMsg.includes('content') && errorMsg.includes('filter')) {
          primaryMessage = ERROR_MESSAGES.CONTENT_FILTER;
          suggestions.push('Review your selection');
        } else if (errorMsg.includes('network') || errorMsg.includes('fetch') || errorMsg.includes('connection')) {
          primaryMessage = ERROR_MESSAGES.CONNECTION_FAILED;
          suggestions.push('Check your internet connection');
        } else if (errorMsg.includes('timeout')) {
          primaryMessage = ERROR_MESSAGES.NETWORK_TIMEOUT;
          suggestions.push('Try again with fewer elements');
        } else if (errorMsg.includes('empty') || errorMsg.includes('no content')) {
          primaryMessage = ERROR_MESSAGES.EMPTY_RESPONSE;
          suggestions.push('Try a different selection or template');
        } else {
          primaryMessage = errorMsg || ERROR_MESSAGES.UNKNOWN_ERROR;
        }
      }
      
      // Add context if provided
      if (context) {
        secondaryMessage = `Context: ${context}`;
      }
      
      // Build comprehensive message
      let fullMessage = primaryMessage;
      
      if (secondaryMessage) {
        fullMessage += `\n\n${secondaryMessage}`;
      }
      
      if (suggestions.length > 0) {
        fullMessage += `\n\n💡 Suggestions:\n• ${suggestions.join('\n• ')}`;
      }
      
      return fullMessage;
    }
    
    function handleError(error, context = '', showRetryOption = false) {
      const comprehensiveMessage = createComprehensiveErrorMessage(error, context);
      
      console.error(`Error in ${context}:`, error);
      
      // Show the error with suggestions
      showTicketStatus(comprehensiveMessage, 'error');
      
      // For certain errors, show retry option
      if (showRetryOption && (error instanceof TimeoutError || error instanceof NetworkError)) {
        setTimeout(() => {
          const retryButton = document.createElement('button');
          retryButton.textContent = 'Retry';
          retryButton.className = 'retry-button';
          retryButton.onclick = () => {
            document.querySelector('.retry-button')?.remove();
            generateEnhancedAITicket();
          };
          
          const statusElement = document.getElementById('ticket-status');
          if (statusElement) {
            statusElement.appendChild(retryButton);
          }
        }, 100);
      }
    }
    
    function withTimeout(promise, ms) {
      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new TimeoutError(`Operation timed out after ${ms}ms`));
        }, ms);
        
        promise
          .then((result) => {
            clearTimeout(timeoutId);
            resolve(result);
          })
          .catch((error) => {
            clearTimeout(timeoutId);
            reject(error);
          });
      });
    }
    
    async function withRetry(operation, maxRetries = 3, timeoutMs = 30000) {
      let lastError;
      
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          return await withTimeout(operation(), timeoutMs);
        } catch (error) {
          lastError = error;
          console.warn(`Attempt ${attempt}/${maxRetries} failed:`, error);
          
          if (attempt === maxRetries) {
            break;
          }
          
          // Exponential backoff
          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
      
      throw lastError;
    }
    
    // ==========================================
    // ENHANCED PROGRESS INDICATOR SYSTEM
    // ==========================================
    
    class ProgressTracker {
      constructor() {
        this.currentStep = 0;
        this.steps = [];
        this.startTime = null;
        this.progressElement = null;
        this.detailsVisible = false;
      }
      
      initializeProgress(steps, showDetails = false) {
        this.steps = steps;
        this.currentStep = 0;
        this.startTime = Date.now();
        this.detailsVisible = showDetails;
        this.createProgressElement();
      }
      
      createProgressElement() {
        // Remove existing progress if any
        const existing = document.getElementById('enhancedProgress');
        if (existing) existing.remove();
        
        // Create progress container
        this.progressElement = document.createElement('div');
        this.progressElement.id = 'enhancedProgress';
        this.progressElement.className = 'progress-container';
        
        // Progress bar
        const progressBar = document.createElement('div');
        progressBar.className = 'progress-bar';
        const progressFill = document.createElement('div');
        progressFill.className = 'progress-fill';
        progressFill.id = 'progressFill';
        progressBar.appendChild(progressFill);
        
        // Progress steps
        const stepsContainer = document.createElement('div');
        stepsContainer.className = 'progress-steps';
        stepsContainer.id = 'progressSteps';
        
        this.steps.forEach((step, index) => {
          const stepElement = document.createElement('div');
          stepElement.className = 'progress-step';
          stepElement.id = `step-${index}`;
          
          const indicator = document.createElement('div');
          indicator.className = 'step-indicator';
          
          const label = document.createElement('span');
          label.textContent = step.label;
          
          stepElement.appendChild(indicator);
          stepElement.appendChild(label);
          stepsContainer.appendChild(stepElement);
        });
        
        // Time indicator
        const timeIndicator = document.createElement('div');
        timeIndicator.className = 'time-indicator';
        timeIndicator.id = 'timeIndicator';
        timeIndicator.textContent = 'Starting...';
        
        // Details section
        const details = document.createElement('div');
        details.className = 'progress-details';
        details.id = 'progressDetails';
        if (this.detailsVisible) {
          details.classList.add('visible');
        }
        
        this.progressElement.appendChild(progressBar);
        this.progressElement.appendChild(stepsContainer);
        this.progressElement.appendChild(timeIndicator);
        this.progressElement.appendChild(details);
        
        // Insert into status area
        const statusEl = document.getElementById('ticketStatus');
        if (statusEl && statusEl.parentNode) {
          statusEl.parentNode.insertBefore(this.progressElement, statusEl.nextSibling);
        }
        
        this.updateDisplay();
      }
      
      updateProgress(stepIndex, status = 'active', details = '') {
        this.currentStep = stepIndex;
        
        // Update step status
        this.steps[stepIndex].status = status;
        if (details) {
          this.steps[stepIndex].details = details;
        }
        
        this.updateDisplay();
      }
      
      updateDisplay() {
        if (!this.progressElement) return;
        
        // Update progress bar
        const progress = (this.currentStep / Math.max(this.steps.length - 1, 1)) * 100;
        const progressFill = document.getElementById('progressFill');
        if (progressFill) {
          progressFill.style.width = `${progress}%`;
        }
        
        // Update step indicators
        this.steps.forEach((step, index) => {
          const stepEl = document.getElementById(`step-${index}`);
          const indicator = stepEl?.querySelector('.step-indicator');
          
          if (stepEl && indicator) {
            stepEl.className = 'progress-step';
            indicator.className = 'step-indicator';
            
            if (step.status === 'completed') {
              stepEl.classList.add('completed');
              indicator.classList.add('completed');
              indicator.innerHTML = '✓';
            } else if (step.status === 'active') {
              stepEl.classList.add('active');
              indicator.classList.add('active');
              indicator.innerHTML = '<div class="loading-spinner"></div>';
            } else if (step.status === 'error') {
              stepEl.classList.add('error');
              indicator.classList.add('error');
              indicator.innerHTML = '✗';
            } else {
              indicator.innerHTML = '';
            }
          }
        });
        
        // Update time indicator
        const timeEl = document.getElementById('timeIndicator');
        if (timeEl && this.startTime) {
          const elapsed = Math.round((Date.now() - this.startTime) / 1000);
          timeEl.textContent = `${elapsed}s elapsed`;
        }
        
        // Update details
        const detailsEl = document.getElementById('progressDetails');
        if (detailsEl && this.detailsVisible) {
          const currentStepDetails = this.steps[this.currentStep]?.details || '';
          const completedSteps = this.steps.filter(s => s.status === 'completed').length;
          const totalSteps = this.steps.length;
          
          detailsEl.innerHTML = `
            <div><strong>Progress:</strong> ${completedSteps}/${totalSteps} steps completed</div>
            ${currentStepDetails ? `<div><strong>Current:</strong> ${currentStepDetails}</div>` : ''}
          `;
        }
      }
      
      completeStep(stepIndex, details = '') {
        this.updateProgress(stepIndex, 'completed', details);
      }
      
      errorStep(stepIndex, details = '') {
        this.updateProgress(stepIndex, 'error', details);
      }
      
      finish(success = true) {
        if (success) {
          // Mark all remaining steps as completed
          for (let i = this.currentStep; i < this.steps.length; i++) {
            this.steps[i].status = 'completed';
          }
          this.currentStep = this.steps.length - 1;
        }
        
        this.updateDisplay();
        
        // Auto-remove after delay
        setTimeout(() => {
          if (this.progressElement) {
            this.progressElement.remove();
          }
        }, success ? 3000 : 5000);
      }
      
      setDetails(visible) {
        this.detailsVisible = visible;
        const detailsEl = document.getElementById('progressDetails');
        if (detailsEl) {
          if (visible) {
            detailsEl.classList.add('visible');
          } else {
            detailsEl.classList.remove('visible');
          }
        }
      }
    }
    
    // Global progress tracker instance
    let progressTracker = new ProgressTracker();
    
    // ==========================================
    // MAIN APPLICATION
    // ==========================================
    
    // Main initialization function
    function initializeApp() {
      console.log('🚀 Figma AI Ticket Generator UI starting...');
      
      // Initialize health metrics directly here
      console.log('🔄 Starting health metrics...');
      
      // Auto-trigger compliance analysis on load
      setTimeout(() => {
        console.log('🔄 Triggering compliance calculation...');
        // Send compliance calculation request to plugin
        if (window.parent && window.parent.postMessage) {
          window.parent.postMessage({ pluginMessage: { type: 'calculate-compliance' } }, '*');
        }
      }, 2000);
      
      console.log('✅ UI initialized successfully');
    }

    // Handle messages from Figma plugin
    function handlePluginMessage(event) {
      try {
        const msg = event.data.pluginMessage;
        if (!msg) return;
        
        console.log('📨 Received message:', msg.type);
        
        switch (msg.type) {
          case 'compliance-results':
            console.log('📊 Compliance results received:', msg.compliance);
            if (msg.compliance) {
              displayHealthMetrics(msg.compliance);
            } else {
              handleError(new ValidationError('Invalid compliance data received'), 'Health metrics', false);
            }
            break;
            
          case 'compliance-error':
            console.log('❌ Compliance error:', msg.message);
            handleError(new Error(msg.message || 'Unknown compliance error'), 'Health metrics calculation', false);
            break;
            
          case 'frame-progress':
            console.log('📈 Frame processing progress:', msg.data);
            if (msg.data && typeof msg.data.current === 'number' && typeof msg.data.total === 'number') {
              const { current, total, nodeName, nodeType } = msg.data;
              const percentage = Math.round((current / total) * 100);
              
              progressTracker.updateProgress(1, 'active', 
                `Processing ${nodeType.toLowerCase()} "${nodeName}" (${current}/${total})`
              );
              
              // Update the progress bar fill if it exists
              const progressFill = document.getElementById('progressFill');
              if (progressFill) {
                const baseProgress = (1 / 2) * 100; // Step 1 out of 2 for initial reading
                const stepProgress = (current / total) * (100 / 3); // 1/3 of total progress for this step
                progressFill.style.width = `${baseProgress + stepProgress}%`;
              }
            }
            break;
            
          case 'frame-data':
            console.log('📋 Frame data received');
            if (msg.data && Array.isArray(msg.data)) {
              frameDataList = msg.data;
              
              // Update progress for frame reading completion
              progressTracker.completeStep(0, 'Selection validated');
              progressTracker.completeStep(1, `${msg.data.length} frame(s) processed`);
              progressTracker.updateProgress(2, 'completed', 'Ready for AI generation');
              
              // Show processing summary with limits information
              let statusMessage = `✅ Processed ${msg.data.length} frame(s)`;
              let statusType = 'success';
              
              if (msg.processingSummary) {
                const summary = msg.processingSummary;
                statusMessage = summary.message;
                
                if (summary.skipped > 0) {
                  statusType = 'warning';
                  statusMessage += `\n\n⚠️ Some frames were simplified due to complexity:\n• ${summary.skipped} frame(s) had processing limits applied\n• This helps prevent memory issues and ensures good performance`;
                }
              }
              
              // Check for limit information in frame data
              const framesWithLimits = msg.data.filter(frame => 
                frame.designSystemContext?.limitsApplied && 
                Object.values(frame.designSystemContext.limitsApplied).some(applied => applied)
              );
              
              if (framesWithLimits.length > 0) {
                statusMessage += `\n\n📊 Processing optimization applied to ${framesWithLimits.length} complex frame(s)`;
              }
              
              showTicketStatus(statusMessage, statusType);
              
              // Auto-proceed to AI generation after a brief delay
              setTimeout(() => {
                progressTracker.finish(true);
                generateEnhancedAITicket();
              }, 800);
              
            } else {
              progressTracker.errorStep(1, 'Invalid frame data received');
              progressTracker.finish(false);
              handleError(new ValidationError(ERROR_MESSAGES.FRAME_READ_ERROR), 'Frame data processing', false);
              setTicketGenerating(false);
            }
            break;
            
          case 'error':
            console.log('❌ Plugin error:', msg.message);
            handleError(new Error(msg.message || 'Unknown plugin error'), 'Plugin operation', false);
            setTicketGenerating(false);
            break;
            
          default:
            console.log('⚠️ Unknown message type:', msg.type);
            break;
        }
      } catch (error) {
        console.error('Error handling plugin message:', error);
        handleError(error, 'Plugin message handling', false);
      }
    }

    // Display health metrics in the UI
    function displayHealthMetrics(compliance) {
      console.log('🎯 Displaying health metrics:', compliance);
      
      // Update overall score
      const overallScoreEl = document.getElementById('overallScore');
      if (overallScoreEl) {
        overallScoreEl.textContent = compliance.overall + '%';
        console.log('✅ Updated overall score to:', compliance.overall + '%');
      } else {
        console.log('❌ overallScore element not found');
      }
      
      // Update individual category scores in the overview cards
      const complianceRateEl = document.getElementById('complianceRate');
      if (complianceRateEl) {
        complianceRateEl.textContent = compliance.overall + '%';
        console.log('✅ Updated compliance rate to:', compliance.overall + '%');
      }
      
      const componentUsageEl = document.getElementById('componentUsage');
      if (componentUsageEl) {
        componentUsageEl.textContent = compliance.breakdown.components.score + '%';
        console.log('✅ Updated component usage to:', compliance.breakdown.components.score + '%');
      }
      
      const tokenAdoptionEl = document.getElementById('tokenAdoption');
      if (tokenAdoptionEl) {
        const tokenScore = Math.round((compliance.breakdown.colors.score + compliance.breakdown.typography.score) / 2);
        tokenAdoptionEl.textContent = tokenScore + '%';
        console.log('✅ Updated token adoption to:', tokenScore + '%');
      }
      
      // Update detailed component analysis
      const standardComponentsEl = document.getElementById('standardComponents');
      if (standardComponentsEl && compliance.breakdown.components) {
        standardComponentsEl.textContent = compliance.breakdown.components.details?.standardComponents || '85%';
        console.log('✅ Updated standard components');
      }
      
      const customComponentsEl = document.getElementById('customComponents');
      if (customComponentsEl && compliance.breakdown.components) {
        customComponentsEl.textContent = compliance.breakdown.components.details?.customComponents || '15%';
        console.log('✅ Updated custom components');
      }
      
      const topComponentEl = document.getElementById('topComponent');
      if (topComponentEl && compliance.breakdown.components) {
        topComponentEl.textContent = compliance.breakdown.components.details?.topComponent || 'Button';
        console.log('✅ Updated top component');
      }
      
      // Update detailed token adoption
      const colorTokensEl = document.getElementById('colorTokens');
      if (colorTokensEl && compliance.breakdown.colors) {
        colorTokensEl.textContent = compliance.breakdown.colors.score + '%';
        console.log('✅ Updated color tokens');
      }
      
      const typographyTokensEl = document.getElementById('typographyTokens');
      if (typographyTokensEl && compliance.breakdown.typography) {
        typographyTokensEl.textContent = compliance.breakdown.typography.score + '%';
        console.log('✅ Updated typography tokens');
      }
      
      const spacingTokensEl = document.getElementById('spacingTokens');
      if (spacingTokensEl && compliance.breakdown.spacing) {
        spacingTokensEl.textContent = compliance.breakdown.spacing.score + '%';
        console.log('✅ Updated spacing tokens');
      }
      
      // Update recommendations
      const recommendationsEl = document.getElementById('healthRecommendations');
      if (recommendationsEl && compliance.recommendations) {
        recommendationsEl.innerHTML = '';
        compliance.recommendations.forEach(rec => {
          const recEl = document.createElement('div');
          recEl.className = 'metric-row';
          recEl.innerHTML = `
            <span class="metric-name">${rec.category}: ${rec.description}</span>
            <span class="metric-score ${rec.priority}">${rec.priority}</span>
          `;
          recommendationsEl.appendChild(recEl);
        });
        console.log('✅ Updated recommendations, count:', compliance.recommendations.length);
      } else {
        console.log('❌ healthRecommendations element not found');
      }
      
      // Hide loading message
      const loadingEl = document.querySelector('.loading-message');
      if (loadingEl) {
        loadingEl.style.display = 'none';
        console.log('✅ Hidden loading message');
      } else {
        console.log('ℹ️ loading-message element not found (might be already hidden)');
      }
    }

    // Set up message listener
    function setupMessageListener() {
      window.onmessage = handlePluginMessage;
      console.log('✅ Message listener set up');
    }

    // Initialize when DOM is ready
    function initializeWhenReady() {
      console.log('🔄 initializeWhenReady called, document.readyState:', document.readyState);
      
      if (document.readyState === 'loading') {
        console.log('📅 DOM still loading, adding event listener...');
        document.addEventListener('DOMContentLoaded', () => {
          console.log('📅 DOMContentLoaded fired!');
          initializeApp();
          setupMessageListener();
        });
      } else {
        console.log('📅 DOM already ready, initializing immediately...');
        initializeApp();
        setupMessageListener();
      }
    }

    // Start the application
    console.log('🚀 About to call initializeWhenReady...');
    initializeWhenReady();
    console.log('✅ initializeWhenReady called');
  </script>
  
  <!-- Enhanced Ticket Generation Script -->
  <script>
    // Enhanced ticket generation functionality
    let frameDataList = [];
    let isGenerating = false;
    
    // Format definitions for different Jira instances
    const OUTPUT_FORMATS = {
      'jira-wiki': {
        name: 'Jira Wiki Markup',
        description: 'Uses *bold*, bullet points, and formatting that works in most Jira instances',
        bold: (text) => `*${text}*`,
        heading: (text) => `h3. ${text}`,
        bullet: '* ',
        numberedList: (num) => `# `,
        codeBlock: (text) => `{code}\n${text}\n{code}`,
        separator: '\n----\n'
      },
      'plain-text': {
        name: 'Plain Text',
        description: 'Simple text format that works everywhere, uses CAPS for emphasis',
        bold: (text) => text.toUpperCase(),
        heading: (text) => `${text.toUpperCase()}\n${'='.repeat(text.length)}`,
        bullet: '- ',
        numberedList: (num) => `${num}. `,
        codeBlock: (text) => `\n${text}\n`,
        separator: '\n' + '='.repeat(50) + '\n'
      },
      'markdown': {
        name: 'Markdown',
        description: 'Standard Markdown format for GitHub, modern tools, and some Jira Cloud instances',
        bold: (text) => `**${text}**`,
        heading: (text) => `### ${text}`,
        bullet: '- ',
        numberedList: (num) => `${num}. `,
        codeBlock: (text) => `\`\`\`\n${text}\n\`\`\``,
        separator: '\n---\n'
      },
      'confluence': {
        name: 'Confluence',
        description: 'Confluence wiki markup for Atlassian Confluence pages',
        bold: (text) => `*${text}*`,
        heading: (text) => `h3. ${text}`,
        bullet: '* ',
        numberedList: (num) => `# `,
        codeBlock: (text) => `{code:theme=RDark}\n${text}\n{code}`,
        separator: '\n----\n'
      }
    };
    
    // Ticket templates with format-agnostic structure
    const TICKET_TEMPLATES = {
      story: {
        name: 'User Story',
        getStructure: (format) => {
          const f = OUTPUT_FORMATS[format];
          return `${f.heading('USER STORY')}

${f.bold('Story:')} As a [user type], I want [functionality] so that [benefit]

${f.bold('Figma Reference:')}
[Figma design link and frame details for easy access]

${f.bold('Acceptance Criteria:')}
${f.bullet}[Specific, testable criteria]
${f.bullet}[Another criteria]
${f.bullet}[Third criteria]

${f.bold('Definition of Done:')}
${f.bullet}[ ] Design specs implemented accurately
${f.bullet}[ ] Responsive behavior tested
${f.bullet}[ ] Accessibility requirements met
${f.bullet}[ ] Code review completed`;
        },
        prompt: 'Create a user story ticket for implementing functionality based on the Figma design. Focus on user value and clear acceptance criteria.'
      },
      task: {
        name: 'Technical Task', 
        getStructure: (format) => {
          const f = OUTPUT_FORMATS[format];
          return `${f.heading('TECHNICAL TASK')}

${f.bold('Task:')} [Clear, actionable task title]

${f.bold('Description:')}
[Detailed technical description with context]

${f.bold('Technical Requirements:')}
${f.bullet}[Specific technical requirement]
${f.bullet}[Another requirement]
${f.bullet}[Third requirement]

${f.bold('Dependencies:')}
${f.bullet}[List any dependencies]

${f.bold('Notes:')}
[Any additional technical considerations]`;
        },
        prompt: 'Create a technical task ticket for implementation work based on the Figma design. Focus on technical requirements and implementation details.'
      },
      component: {
        name: 'UI Component',
        getStructure: (format) => {
          const f = OUTPUT_FORMATS[format];
          return `${f.heading('UI COMPONENT')}

${f.bold('Component:')} [Component Name]

${f.bold('Figma Reference:')}
[Figma design link and frame details]

${f.bold('Purpose:')}
[Description of component purpose and usage]

${f.bold('Props/API:')}
${f.bullet}[List expected props/parameters]
${f.bullet}[Another prop]

${f.bold('Variants/States:')}
${f.bullet}[List component variants]
${f.bullet}[Different states]

${f.bold('Design Tokens:')}
${f.bullet}Colors: [List required color tokens]
${f.bullet}Typography: [List font/text styles]
${f.bullet}Spacing: [List spacing values]

${f.bold('Accessibility:')}
${f.bullet}[ARIA requirements]
${f.bullet}[Keyboard navigation]
${f.bullet}[Screen reader support]`;
        },
        prompt: 'Create a UI component implementation ticket based on the Figma design. Include detailed API specifications, variants, and accessibility requirements.'
      },
      feature: {
        name: 'Feature Implementation',
        getStructure: (format) => {
          const f = OUTPUT_FORMATS[format];
          return `${f.heading('FEATURE IMPLEMENTATION')}

${f.bold('Feature:')} [Feature Name]

${f.bold('Figma Reference:')}
[Figma design link and frame details]

${f.bold('User Value:')}
[Explain the value this feature provides to users]

${f.bold('Functional Requirements:')}
${f.bullet}[Specific functional requirement]
${f.bullet}[Another requirement]

${f.bold('User Experience:')}
${f.bullet}[UX considerations]
${f.bullet}[Interaction patterns]

${f.bold('Business Logic:')}
${f.bullet}[Business rules]
${f.bullet}[Edge cases]

${f.bold('Integration Points:')}
${f.bullet}[API endpoints]
${f.bullet}[Data requirements]`;
        },
        prompt: 'Create a feature implementation ticket based on the Figma design. Focus on user value, functional requirements, and business logic.'
      },
      bug: {
        name: 'Bug Fix',
        getStructure: (format) => {
          const f = OUTPUT_FORMATS[format];
          return `${f.heading('BUG FIX')}

${f.bold('Bug Summary:')} [Brief description of the bug]

${f.bold('Current Behavior:')}
[What's happening now]

${f.bold('Expected Behavior:')}
[What should happen instead]

${f.bold('Steps to Reproduce:')}
${f.numberedList(1)}[First step]
${f.numberedList(2)}[Second step]
${f.numberedList(3)}[Third step]

${f.bold('Impact:')}
[Who is affected and how]

${f.bold('Root Cause Analysis:')}
[Analysis of why this is happening]

${f.bold('Solution:')}
[Proposed fix approach]`;
        },
        prompt: 'Create a bug fix ticket based on the Figma design that shows the correct behavior. Focus on clear reproduction steps and expected outcomes.'
      },
      epic: {
        name: 'Epic',
        getStructure: (format) => {
          const f = OUTPUT_FORMATS[format];
          return `${f.heading('EPIC')}

${f.bold('Epic:')} [Epic Name]

${f.bold('Vision:')}
[High-level vision for this epic]

${f.bold('User Problems:')}
${f.bullet}[Problem this epic solves]
${f.bullet}[Another problem]

${f.bold('Success Metrics:')}
${f.bullet}[How we'll measure success]
${f.bullet}[Another metric]

${f.bold('User Stories:')}
${f.bullet}[High-level user story]
${f.bullet}[Another story]
${f.bullet}[Third story]

${f.bold('Dependencies:')}
[List any dependencies on other teams/systems]

${f.bold('Timeline:')}
[Estimated timeline and milestones]`;
        },
        prompt: 'Create an epic ticket based on the Figma design. Focus on high-level vision, user problems, and success metrics.'
      },
      improvement: {
        name: 'Improvement',
        getStructure: (format) => {
          const f = OUTPUT_FORMATS[format];
          return `${f.heading('IMPROVEMENT')}

${f.bold('Improvement:')} [What we're improving]

${f.bold('Current State:')}
[How things work today]

${f.bold('Proposed State:')}
[How things will work after improvement]

${f.bold('Benefits:')}
${f.bullet}[Benefit to users]
${f.bullet}[Benefit to business]
${f.bullet}[Technical benefit]

${f.bold('Implementation Plan:')}
${f.numberedList(1)}[First step]
${f.numberedList(2)}[Second step]
${f.numberedList(3)}[Third step]

${f.bold('Success Criteria:')}
${f.bullet}[How we'll know it's successful]
${f.bullet}[Measurable outcome]`;
        },
        prompt: 'Create an improvement ticket based on the Figma design. Focus on current vs proposed state and clear benefits.'
      },
      research: {
        name: 'Design Research',
        getStructure: (format) => {
          const f = OUTPUT_FORMATS[format];
          return `${f.heading('DESIGN RESEARCH')}

${f.bold('Research Question:')} [What we want to learn]

${f.bold('Hypothesis:')}
[What we think we'll discover]

${f.bold('Research Methods:')}
${f.bullet}[Method 1 - e.g., user interviews]
${f.bullet}[Method 2 - e.g., usability testing]

${f.bold('Participants:')}
[Who we'll research with]

${f.bold('Success Metrics:')}
${f.bullet}[What constitutes successful research]
${f.bullet}[Deliverable expectations]

${f.bold('Timeline:')}
[Research timeline and milestones]

${f.bold('Deliverables:')}
${f.bullet}[Research report]
${f.bullet}[Design recommendations]
${f.bullet}[Other deliverables]`;
        },
        prompt: 'Create a design research ticket based on the Figma design. Focus on research questions, methods, and expected deliverables.'
      },
      custom: {
        name: 'Custom',
        getStructure: (format) => {
          const f = OUTPUT_FORMATS[format];
          return `${f.heading('CUSTOM TICKET')}

${f.bold('Title:')} [Custom ticket title]

${f.bold('Description:')}
[Detailed description]

${f.bold('Requirements:')}
${f.bullet}[Requirement 1]
${f.bullet}[Requirement 2]

${f.bold('Acceptance Criteria:')}
${f.bullet}[Criteria 1]
${f.bullet}[Criteria 2]

${f.bold('Notes:')}
[Additional notes and context]`;
        },
        prompt: 'Create a custom ticket based on the Figma design and additional instructions provided.'
      }
    };
    
    // Initialize enhanced ticket generation
    function initializeEnhancedTicketGeneration() {
      const generateBtn = document.getElementById('generate');
      const templateSelect = document.getElementById('template');
      const outputFormatSelect = document.getElementById('outputFormat');
      const prioritySelect = document.getElementById('priority');
      const storyPointsSelect = document.getElementById('storyPoints');
      const labelsInput = document.getElementById('labels');
      const customPromptInput = document.getElementById('customPrompt');
      const previewContent = document.getElementById('previewContent');
      const outputTextarea = document.getElementById('output');
      
      if (!generateBtn || !templateSelect) {
        console.log('❌ Enhanced ticket generation elements not found');
        return;
      }
      
      // Update template preview when template or format changes
      templateSelect.addEventListener('change', updateTemplatePreview);
      if (outputFormatSelect) {
        outputFormatSelect.addEventListener('change', updateTemplatePreview);
        outputFormatSelect.addEventListener('change', updateFormatHelp);
        // Initialize format help
        updateFormatHelp();
      }
      
      // Initialize with current template
      updateTemplatePreview();
      
      // Enhanced generate button handler
      generateBtn.addEventListener('click', generateEnhancedTicket);
      
      // Initialize copy button
      initializeCopyButton();
      
      console.log('✅ Enhanced ticket generation initialized');
    }
    
    function updateFormatHelp() {
      const outputFormatSelect = document.getElementById('outputFormat');
      const formatHelp = document.getElementById('formatHelp');
      
      if (!outputFormatSelect || !formatHelp) return;
      
      const selectedFormat = outputFormatSelect.value;
      const format = OUTPUT_FORMATS[selectedFormat];
      
      if (format) {
        formatHelp.textContent = format.description;
      }
    }
    
    function updateTemplatePreview() {
      const templateSelect = document.getElementById('template');
      const outputFormatSelect = document.getElementById('outputFormat');
      const previewContent = document.getElementById('previewContent');
      
      if (!templateSelect || !previewContent) return;
      
      const selectedTemplate = templateSelect.value;
      const selectedFormat = outputFormatSelect ? outputFormatSelect.value : 'jira-wiki';
      const template = TICKET_TEMPLATES[selectedTemplate];
      
      if (template) {
        previewContent.textContent = template.getStructure(selectedFormat);
        previewContent.classList.add('loaded');
      } else {
        previewContent.textContent = 'Select a template to see the structure';
        previewContent.classList.remove('loaded');
      }
    }
    
    function generateEnhancedTicket() {
      if (isGenerating) return;
      
      const apiKey = document.getElementById('apiKey')?.value?.trim();
      if (!apiKey) {
        showTicketStatus('Please enter your OpenAI API key', 'error');
        return;
      }
      
      setTicketGenerating(true);
      
      // Initialize progress for frame reading phase
      const initialSteps = [
        { label: 'Validating Selection', status: 'active' },
        { label: 'Reading Frames', status: 'pending' },
        { label: 'Ready for AI', status: 'pending' }
      ];
      
      progressTracker.initializeProgress(initialSteps, false);
      showTicketStatus('🔍 Reading selected frames...', 'loading');
      
      // Request frame data from Figma
      parent.postMessage({ 
        pluginMessage: { type: 'generate-ticket' } 
      }, '*');
    }
    
    async function generateEnhancedAITicket() {
      // Validate inputs first
      try {
        validateInputs();
      } catch (error) {
        handleError(error, 'Input validation', false);
        setTicketGenerating(false);
        return;
      }
      
      if (!frameDataList.length) {
        handleError(new ValidationError(ERROR_MESSAGES.NO_SELECTION), 'Frame data validation', false);
        setTicketGenerating(false);
        return;
      }
      
      // Initialize enhanced progress tracking
      const progressSteps = [
        { label: 'Validation', status: 'completed' },
        { label: 'Processing Frames', status: 'completed' },
        { label: 'Building Prompt', status: 'pending' },
        { label: 'AI Generation', status: 'pending' },
        { label: 'Formatting', status: 'pending' }
      ];
      
      progressTracker.initializeProgress(progressSteps, true);
      showTicketStatus('🚀 Generating enhanced ticket with AI...', 'loading');
      
      try {
        // Step 1: Build prompt
        progressTracker.updateProgress(2, 'active', 'Creating optimized prompt from frame data');
        const prompt = createEnhancedPrompt(frameDataList);
        const apiKey = document.getElementById('apiKey').value.trim();
        const model = document.getElementById('model').value;
        
        await new Promise(resolve => setTimeout(resolve, 300)); // Brief pause for UX
        progressTracker.completeStep(2, `Generated ${Math.round(prompt.length/1000)}k character prompt`);
        
        // Step 2: AI Generation
        progressTracker.updateProgress(3, 'active', 'Connecting to OpenAI API...');
        
        // Use timeout and retry for OpenAI API call
        const response = await withRetry(
          async () => {
            progressTracker.updateProgress(3, 'active', `Generating with ${model}... (up to 30s)`);
            
            const fetchResponse = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`,
              },
              body: JSON.stringify({
                model: model,
                messages: [
                  { 
                    role: 'system', 
                    content: 'You are an expert Jira ticket creator specializing in UI/UX implementation. Generate detailed, structured tickets with clear acceptance criteria, technical requirements, and design specifications. Always include specific Figma references and maintain consistency with the requested template format.' 
                  },
                  { role: 'user', content: prompt }
                ],
                temperature: 0.3, // Lower temperature for more consistent structure
                max_tokens: 1500 // Increased for more detailed tickets
              }),
            });
            
            // Handle HTTP errors properly
            if (!fetchResponse.ok) {
              let errorMessage = `HTTP ${fetchResponse.status}`;
              try {
                const errorData = await fetchResponse.json();
                errorMessage = errorData.error?.message || errorMessage;
              } catch (parseError) {
                // If we can't parse the error response, use the status
              }
              throw new APIError(errorMessage, fetchResponse.status, 'OpenAI API');
            }
            
            return fetchResponse;
          },
          2, // Max 2 retries
          30000 // 30 second timeout for OpenAI API
        );
        
        const data = await response.json();
        
        // Validate response data
        if (!data.choices || !data.choices[0] || !data.choices[0].message || !data.choices[0].message.content) {
          throw new ValidationError(ERROR_MESSAGES.EMPTY_RESPONSE);
        }
        
        progressTracker.completeStep(3, `Generated ${Math.round(ticket.length/1000)}k character response`);
        
        // Step 3: Format and finalize
        progressTracker.updateProgress(4, 'active', 'Applying Jira formatting and metadata');
        
        const enhancedTicket = addJiraMetadata(ticket);
        
        await new Promise(resolve => setTimeout(resolve, 200)); // Brief pause for UX
        progressTracker.completeStep(4, 'Applied formatting and Figma links');
        
        document.getElementById('output').value = enhancedTicket;
        document.getElementById('copy').disabled = false;
        
        // Complete progress and show success
        progressTracker.finish(true);
        showTicketStatus('✅ Enhanced ticket generated successfully!', 'success');
        
      } catch (error) {
        // Mark current step as error and finish
        if (progressTracker.currentStep < progressSteps.length) {
          progressTracker.errorStep(progressTracker.currentStep, error.message);
        }
        progressTracker.finish(false);
        
        handleError(error, 'AI ticket generation', true);
      } finally {
        setTicketGenerating(false);
      }
    }
    
    function validateInputs() {
      const apiKey = document.getElementById('apiKey').value.trim();
      const model = document.getElementById('model').value;
      const template = document.getElementById('template').value;
      
      if (!apiKey) {
        throw new ValidationError(ERROR_MESSAGES.MISSING_API_KEY);
      }
      
      if (apiKey.length < 20 || !apiKey.startsWith('sk-')) {
        throw new ValidationError(ERROR_MESSAGES.INVALID_API_KEY);
      }
      
      if (!model) {
        throw new ValidationError('Please select an AI model.');
      }
      
      if (!template || !TICKET_TEMPLATES[template]) {
        throw new ValidationError(ERROR_MESSAGES.INVALID_TEMPLATE);
      }

    }
    
    function createEnhancedPrompt(frameDataList) {
      const templateSelect = document.getElementById('template');
      const outputFormatSelect = document.getElementById('outputFormat');
      const prioritySelect = document.getElementById('priority');
      const storyPointsSelect = document.getElementById('storyPoints');
      const labelsInput = document.getElementById('labels');
      const customPromptInput = document.getElementById('customPrompt');
      
      const selectedTemplate = templateSelect.value;
      const selectedFormat = outputFormatSelect ? outputFormatSelect.value : 'jira-wiki';
      const template = TICKET_TEMPLATES[selectedTemplate];
      const format = OUTPUT_FORMATS[selectedFormat];
      const priority = prioritySelect.value;
      const storyPoints = storyPointsSelect.value;
      const labels = labelsInput.value;
      const customInstructions = customPromptInput.value.trim();
      
      let prompt = `${template.prompt}\n\n`;
      
      // Add format-specific instructions
      prompt += `CRITICAL: Use ${format.name} formatting. Here are the formatting rules:\n`;
      prompt += `- Bold text: Use "${format.bold('example')}" (not **example**)\n`;
      prompt += `- Headings: Use "${format.heading('Example')}" \n`;
      prompt += `- Bullet points: Use "${format.bullet}" at the start of each line\n`;
      prompt += `- Numbered lists: Use "${format.numberedList(1)}" for numbered items\n\n`;
      
      // Add template structure instructions
      prompt += `Please use this EXACT structure and formatting for the ticket:\n\n${template.getStructure(selectedFormat)}\n\n`;
      
      // Add Figma frame data
      prompt += `**Figma Design Context:**\n`;
      
      // Generate Figma file link from frame data
      let figmaFileUrl = '';
      if (frameDataList.length > 0 && frameDataList[0].fileKey) {
        figmaFileUrl = `https://www.figma.com/design/${frameDataList[0].fileKey}`;
        if (frameDataList[0].id) {
          figmaFileUrl += `?node-id=${encodeURIComponent(frameDataList[0].id.replace(':', '-'))}`;
        }
        prompt += `\n**Figma File Link:** ${figmaFileUrl}\n`;
      }
      
      frameDataList.forEach((frame, index) => {
        prompt += `\nFrame ${index + 1}: "${frame.name}"\n`;
        prompt += `- Page: ${frame.pageName}\n`;
        prompt += `- Type: ${frame.type}\n`;
        prompt += `- Dimensions: ${frame.dimensions.width}x${frame.dimensions.height}px\n`;
        prompt += `- Elements: ${frame.nodeCount} child elements\n`;
        
        // Add individual frame link
        if (frame.fileKey && frame.id) {
          const frameUrl = `https://www.figma.com/design/${frame.fileKey}?node-id=${encodeURIComponent(frame.id.replace(':', '-'))}`;
          prompt += `- Direct Link: ${frameUrl}\n`;
        }
        
        if (frame.textContent.length > 0) {
          prompt += `- Text Content: ${frame.textContent.map(t => `"${t.content}"`).join(', ')}\n`;
        }
        
        if (frame.components.length > 0) {
          prompt += `- Components: ${frame.components.map(c => c.masterComponent).join(', ')}\n`;
        }
        
        if (frame.colors.length > 0) {
          prompt += `- Colors Used: ${frame.colors.join(', ')}\n`;
        }
        
        if (frame.hasPrototype) {
          prompt += `- Has Interactive Prototype\n`;
        }
        
        // Add design system context if available
        if (frame.designSystemContext) {
          const context = frame.designSystemContext;
          
          if (context.designSystem) {
            prompt += `\n**Design System Context:**\n`;
            prompt += `- Design System: ${context.designSystem.name}\n`;
            prompt += `- Confidence: ${Math.round(context.designSystem.detectionConfidence * 100)}%\n`;
          }
          
          if (context.complianceReport) {
            prompt += `- Overall Compliance: ${context.complianceReport.overall}%\n`;
            prompt += `- Colors: ${context.complianceReport.breakdown.colors.score}%\n`;
            prompt += `- Typography: ${context.complianceReport.breakdown.typography.score}%\n`;
            prompt += `- Components: ${context.complianceReport.breakdown.components.score}%\n`;
            
            if (context.complianceReport.recommendations && context.complianceReport.recommendations.length > 0) {
              prompt += `\n**Design System Recommendations:**\n`;
              context.complianceReport.recommendations.slice(0, 3).forEach(rec => {
                prompt += `- [${rec.priority.toUpperCase()}] ${rec.category}: ${rec.description}\n`;
              });
            }
          }
        }
      });
      
      // Add ticket metadata context
      prompt += `\n**Ticket Configuration:**\n`;
      prompt += `- Output Format: ${format.name}\n`;
      prompt += `- Priority: ${priority}\n`;
      if (storyPoints) prompt += `- Story Points: ${storyPoints}\n`;
      if (labels) prompt += `- Labels: ${labels}\n`;
      
      // Add custom instructions
      if (customInstructions) {
        prompt += `\n**Additional Instructions:**\n${customInstructions}\n`;
      }
      
      // Add specific formatting instructions
      prompt += `\n**IMPORTANT FORMATTING INSTRUCTIONS:**\n`;
      prompt += `- Use ONLY the ${format.name} formatting specified above\n`;
      prompt += `- Use the exact structure provided - do not deviate from it\n`;
      prompt += `- ALWAYS include the Figma file link provided above in a prominent "Figma Reference" or "Design Link" section\n`;
      prompt += `- Include specific measurements, colors, and typography details from the Figma frames\n`;
      prompt += `- Reference design system components and tokens when applicable\n`;
      prompt += `- Make acceptance criteria specific and testable\n`;
      prompt += `- Include accessibility considerations (WCAG 2.1 AA compliance)\n`;
      prompt += `- Add relevant technical considerations for implementation\n`;
      prompt += `- Keep the content professional and actionable\n`;
      prompt += `- Do NOT use Markdown formatting (like **bold** or ## headers) unless the format is specifically Markdown\n`;
      prompt += `- The Figma link is CRITICAL - ensure it's included in every ticket for design reference\n`;
      
      return prompt;
    }
    
    function addJiraMetadata(ticketContent) {
      const prioritySelect = document.getElementById('priority');
      const storyPointsSelect = document.getElementById('storyPoints');
      const labelsInput = document.getElementById('labels');
      const templateSelect = document.getElementById('template');
      
      const priority = prioritySelect.value;
      const storyPoints = storyPointsSelect.value;
      const labels = labelsInput.value;
      const issueType = TICKET_TEMPLATES[templateSelect.value].name;
      
      let metadata = `**JIRA TICKET METADATA**\n`;
      metadata += `Issue Type: ${issueType}\n`;
      metadata += `Priority: ${priority.charAt(0).toUpperCase() + priority.slice(1)}\n`;
      if (storyPoints) metadata += `Story Points: ${storyPoints}\n`;
      if (labels) metadata += `Labels: ${labels}\n`;
      metadata += `\n${'='.repeat(50)}\n\n`;
      
      return metadata + ticketContent;
    }
    
    function showTicketStatus(message, type) {
      // Create or update status element
      let statusEl = document.getElementById('ticketStatus');
      if (!statusEl) {
        statusEl = document.createElement('div');
        statusEl.id = 'ticketStatus';
        statusEl.className = 'status-message';
        const outputSection = document.querySelector('.output-section');
        if (outputSection) {
          outputSection.insertBefore(statusEl, outputSection.firstChild);
        }
      }
      
      statusEl.textContent = message;
      statusEl.className = `status-message ${type}`;
      
      // Auto-hide success/error messages after 5 seconds
      if (type === 'success' || type === 'error') {
        setTimeout(() => {
          statusEl.style.display = 'none';
        }, 5000);
      } else {
        statusEl.style.display = 'block';
      }
      
      console.log(`[${type.toUpperCase()}] ${message}`);
    }
    
    function initializeCopyButton() {
      const copyBtn = document.getElementById('copy');
      if (copyBtn) {
        copyBtn.addEventListener('click', () => {
          const output = document.getElementById('output');
          if (output && output.value) {
            copyToClipboard(output.value);
          } else {
            handleError(new ValidationError('No ticket content to copy'), 'Copy operation', false);
          }
        });
      }
    }
    
    async function copyToClipboard(text) {
      try {
        // Try modern clipboard API first
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          showTicketStatus('✅ Ticket copied to clipboard!', 'success');
          return;
        }
        
        // Fallback to text selection method
        const tempTextArea = document.createElement('textarea');
        tempTextArea.value = text;
        tempTextArea.style.position = 'fixed';
        tempTextArea.style.left = '-999999px';
        tempTextArea.style.top = '-999999px';
        document.body.appendChild(tempTextArea);
        
        tempTextArea.focus();
        tempTextArea.select();
        
        const successful = document.execCommand('copy');
        document.body.removeChild(tempTextArea);
        
        if (successful) {
          showTicketStatus('✅ Ticket copied to clipboard! (Use Ctrl+V to paste)', 'success');
        } else {
          throw new Error('execCommand failed');
        }
        
      } catch (error) {
        console.warn('Copy to clipboard failed:', error);
        
        // Final fallback - select the textarea content
        const output = document.getElementById('output');
        if (output) {
          output.select();
          output.setSelectionRange(0, 99999);
          showTicketStatus('📋 Text selected - use Ctrl+C to copy, then Ctrl+V to paste', 'warning');
        } else {
          handleError(new Error(ERROR_MESSAGES.CLIPBOARD_ERROR), 'Clipboard operation', false);
        }
      }
    }
    
    function setTicketGenerating(generating) {
      isGenerating = generating;
      const generateBtn = document.getElementById('generate');
      if (generateBtn) {
        generateBtn.disabled = generating;
        generateBtn.textContent = generating ? '⏳ Generating...' : '📋 Generate Ticket from Selection';
      }
    }
    
    // Message handler for frame data and errors
    window.addEventListener('message', (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;
      
      console.log('📨 Enhanced ticket handler received:', msg.type);
      
      if (msg.type === 'frame-data') {
        frameDataList = msg.data;
        generateEnhancedAITicket();
      }
      
      if (msg.type === 'error') {
        console.log('❌ Ticket generation error:', msg.message);
        showTicketStatus(msg.message, 'error');
        setTicketGenerating(false);
      }
    });
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeEnhancedTicketGeneration);
    } else {
      initializeEnhancedTicketGeneration();
    }
  </script>
  
  <!-- Tab System Script -->
  <script>
    // Tab system functionality
    function initializeTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');
      
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');
          
          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          
          // Add active class to clicked button and corresponding content
          button.classList.add('active');
          document.getElementById(targetTab + '-tab').classList.add('active');
          
          // Save the active tab preference (with Figma-safe localStorage handling)
          try {
            if (typeof localStorage !== 'undefined') {
              localStorage.setItem('activeTab', targetTab);
            }
          } catch(e) {
            // localStorage disabled in Figma - silently ignore
          }
        });
      });
      
      // Restore saved tab preference (with Figma-safe localStorage handling)
      try {
        if (typeof localStorage !== 'undefined') {
          const savedTab = localStorage.getItem('activeTab');
          if (savedTab) {
            const savedButton = document.querySelector(`[data-tab="${savedTab}"]`);
            if (savedButton) {
              savedButton.click();
            }
          }
        }
      } catch(e) {
        // localStorage disabled in Figma - silently ignore
      }
    }
    
    // Initialize tabs when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeTabs);
    } else {
      initializeTabs();
    }
  </script>
</body>
</html>