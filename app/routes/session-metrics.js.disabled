/**
 * Session Metrics API Routes
 * 
 * REST API endpoints for accessing session performance metrics, health status,
 * and persistence indicators for dashboard integration.
 */

import express from 'express';
import { SessionMetricsService } from '../../core/services/session-metrics-service.js';
import { Logger } from '../../core/utils/logger.js';

const router = express.Router();
const logger = new Logger('SessionMetricsAPI');
const sessionMetricsService = new SessionMetricsService();

/**
 * GET /api/session-metrics/status
 * Get overall session management health status
 */
router.get('/status', async (req, res) => {
  try {
    const metrics = sessionMetricsService.getMetrics();
    
    res.json({
      success: true,
      data: {
        health: metrics.health,
        uptime: metrics.uptime,
        activeManagers: metrics.sessionManagers,
        timestamp: metrics.timestamp
      }
    });
  } catch (error) {
    logger.error('Failed to get session status:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve session status',
      details: error.message
    });
  }
});

/**
 * GET /api/session-metrics/performance
 * Get detailed performance metrics
 */
router.get('/performance', async (req, res) => {
  try {
    const metrics = sessionMetricsService.getMetrics();
    
    res.json({
      success: true,
      data: {
        sessions: metrics.sessions,
        performance: metrics.performance,
        cache: metrics.cache,
        services: metrics.services,
        timestamp: Date.now()
      }
    });
  } catch (error) {
    logger.error('Failed to get performance metrics:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve performance metrics',
      details: error.message
    });
  }
});

/**
 * GET /api/session-metrics/realtime
 * Get real-time metrics for live dashboard updates
 */
router.get('/realtime', async (req, res) => {
  try {
    const realtimeMetrics = sessionMetricsService.getRealTimeMetrics();
    
    res.json({
      success: true,
      data: realtimeMetrics,
      timestamp: Date.now()
    });
  } catch (error) {
    logger.error('Failed to get realtime metrics:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve realtime metrics',
      details: error.message
    });
  }
});

/**
 * GET /api/session-metrics/persistence
 * Get session persistence indicators (Redis vs Memory)
 */
router.get('/persistence', async (req, res) => {
  try {
    const persistenceIndicators = sessionMetricsService.getSessionPersistenceIndicators();
    
    res.json({
      success: true,
      data: {
        indicators: persistenceIndicators,
        summary: {
          totalManagers: Object.keys(persistenceIndicators).length,
          redisConnected: Object.values(persistenceIndicators).filter(i => i.redisConnected).length,
          memoryFallback: Object.values(persistenceIndicators).filter(i => i.memoryFallback).length,
          healthStatus: Object.values(persistenceIndicators).every(i => i.redisConnected) ? 'optimal' : 
            Object.values(persistenceIndicators).some(i => i.redisConnected) ? 'partial' : 'degraded'
        },
        timestamp: Date.now()
      }
    });
  } catch (error) {
    logger.error('Failed to get persistence indicators:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve persistence indicators',
      details: error.message
    });
  }
});

/**
 * GET /api/session-metrics/cache-stats
 * Get detailed cache performance statistics
 */
router.get('/cache-stats', async (req, res) => {
  try {
    const metrics = sessionMetricsService.getMetrics();
    const realtimeMetrics = sessionMetricsService.getRealTimeMetrics();
    
    const cacheStats = {
      overall: {
        hitRate: metrics.cache.hitRate,
        totalHits: metrics.cache.hits,
        totalMisses: metrics.cache.misses,
        totalRequests: metrics.cache.hits + metrics.cache.misses
      },
      recent: {
        hitRate: realtimeMetrics.cache.hitRate,
        hits: realtimeMetrics.cache.recentHits,
        misses: realtimeMetrics.cache.recentMisses
      },
      performance: {
        averageResponseTime: metrics.performance.averageResponseTime,
        cacheEfficiency: metrics.cache.hitRate > 70 ? 'excellent' : 
          metrics.cache.hitRate > 50 ? 'good' : 
          metrics.cache.hitRate > 30 ? 'fair' : 'poor'
      }
    };
    
    res.json({
      success: true,
      data: cacheStats,
      timestamp: Date.now()
    });
  } catch (error) {
    logger.error('Failed to get cache stats:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve cache statistics',
      details: error.message
    });
  }
});

/**
 * GET /api/session-metrics/health-check
 * Comprehensive health check endpoint
 */
router.get('/health-check', async (req, res) => {
  try {
    const metrics = sessionMetricsService.getMetrics();
    
    const healthCheck = {
      status: metrics.health.status,
      score: metrics.health.overallScore,
      issues: metrics.health.issues,
      checks: {
        sessionManagers: metrics.sessionManagers.length > 0,
        performance: metrics.performance.averageResponseTime < 500,
        cache: metrics.cache.hitRate > 30,
        uptime: metrics.uptime > 0
      },
      summary: {
        managersActive: metrics.sessionManagers.length,
        activeSessions: metrics.sessions.active,
        issueCount: metrics.health.issues.length,
        lastCheck: metrics.health.lastCheck
      }
    };
    
    const httpStatus = metrics.health.status === 'healthy' ? 200 : 
      metrics.health.status === 'degraded' ? 200 : 
      metrics.health.status === 'poor' ? 503 : 503;
    
    res.status(httpStatus).json({
      success: true,
      data: healthCheck,
      timestamp: Date.now()
    });
  } catch (error) {
    logger.error('Health check failed:', error);
    res.status(500).json({
      success: false,
      error: 'Health check failed',
      details: error.message,
      timestamp: Date.now()
    });
  }
});

/**
 * POST /api/session-metrics/event
 * Manually record a session event (for testing or external integration)
 */
router.post('/event', async (req, res) => {
  try {
    const { managerName, eventType, data } = req.body;
    
    if (!managerName || !eventType) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: managerName and eventType'
      });
    }
    
    sessionMetricsService.recordEvent(managerName, eventType, data);
    
    res.json({
      success: true,
      message: `Event ${eventType} recorded for ${managerName}`,
      timestamp: Date.now()
    });
  } catch (error) {
    logger.error('Failed to record event:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to record event',
      details: error.message
    });
  }
});

/**
 * WebSocket endpoint for real-time metrics streaming
 */
router.get('/stream', (req, res) => {
  // Set headers for Server-Sent Events
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Cache-Control'
  });

  // Send initial data
  const sendMetrics = () => {
    try {
      const realtimeMetrics = sessionMetricsService.getRealTimeMetrics();
      res.write(`data: ${JSON.stringify({
        type: 'metrics',
        data: realtimeMetrics,
        timestamp: Date.now()
      })}\\n\\n`);
    } catch (error) {
      logger.error('Failed to send metrics stream:', error);
      res.write(`data: ${JSON.stringify({
        type: 'error',
        error: 'Failed to get metrics',
        timestamp: Date.now()
      })}\\n\\n`);
    }
  };

  // Send metrics immediately
  sendMetrics();

  // Send metrics every 5 seconds
  const interval = setInterval(sendMetrics, 5000);

  // Cleanup on client disconnect
  req.on('close', () => {
    clearInterval(interval);
    logger.debug('Metrics stream client disconnected');
  });

  req.on('error', (error) => {
    clearInterval(interval);
    logger.error('Metrics stream error:', error);
  });
});

export default router;