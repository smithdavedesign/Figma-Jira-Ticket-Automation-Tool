import type { FigmaExtractor, ExtractionParams, MetadataOptions, TokenExtractionOptions, AssetExtractionOptions, CodeGenerationOptions, PerformanceMonitor, DataCache, DataValidator } from './interfaces.js';
import type { FigmaNodeMetadata, AssetMetadata, DesignTokens, CodeGenerationHints, ValidationResult, PerformanceMetrics, ExtractionResult } from './types.js';
export declare class FigmaDataExtractor implements FigmaExtractor {
    private performanceMonitor;
    private cache;
    private validator;
    private figmaApiKey;
    private baseUrl;
    constructor(figmaApiKey: string, performanceMonitor: PerformanceMonitor, cache: DataCache, validator: DataValidator);
    extractWithHierarchy(fileKey: string, nodeIds?: string[], options?: ExtractionParams['options']): Promise<ExtractionResult>;
    private extractEnhancedMetadata;
    private processNodeWithHierarchy;
    private buildNodeHierarchy;
    private buildLayerInfo;
    private extractComponentProperties;
    private extractComponentOverrides;
    private extractDesignSystemLinks;
    private generateExportScreenshots;
    private extractLayerTokens;
    private extractUsedComponents;
    private inferOverrideType;
    private extractBaseNodeMetadata;
    private fetchFigmaData;
    private inferComponentType;
    private extractNodeDesignTokens;
    private inferSemanticRole;
    private extractInteractionStates;
    private extractAccessibilityInfo;
    private inferAccessibilityRole;
    private generateNodeCodeHints;
    private generateComponentName;
    private extractNodeProps;
    private extractNodeStyles;
    private generateImports;
    private generateExports;
    private generateTestSuggestions;
    private generateDocumentation;
    private generateOptimizationHints;
    private rgbToHex;
    extract(params: ExtractionParams): Promise<ExtractionResult>;
    extractMetadata(nodeIds: string[], options?: MetadataOptions): Promise<FigmaNodeMetadata[]>;
    extractDesignTokens(fileKey: string, options?: TokenExtractionOptions): Promise<DesignTokens>;
    extractAssets(nodeIds: string[], options?: AssetExtractionOptions): Promise<AssetMetadata[]>;
    generateCodeHints(metadata: FigmaNodeMetadata[], options?: CodeGenerationOptions): Promise<CodeGenerationHints[]>;
    validateExtraction(result: ExtractionResult): Promise<ValidationResult>;
    getPerformanceMetrics(): PerformanceMetrics;
    private parseSource;
    private createCacheKey;
    private getCacheTTL;
    private fetchNodeMetadata;
    private enrichNodeMetadata;
    private analyzeComponentType;
    private determineSemanticRole;
    private extractColorsFromPaints;
    private extractTypographyFromText;
    private rgbaToHex;
    private extractColorTokens;
    private extractTypographyTokens;
    private extractSpacingTokens;
    private extractBorderTokens;
    private extractShadowTokens;
    private extractEffectTokens;
    private identifyAssetNodes;
    private extractAssetFromNode;
    private optimizeAssets;
    private analyzeNodeForCodeGeneration;
}
//# sourceMappingURL=extractor.d.ts.map