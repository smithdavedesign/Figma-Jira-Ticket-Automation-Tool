<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Enhanced Figma Plugin</title>
  <style>
    /* Modern CSS Reset and Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
      line-height: 1.5;
      background: #f8fafc;
      color: #1a202c;
      padding: 20px;
    }

    #app {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 24px;
      text-align: center;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .subtitle {
      opacity: 0.9;
      font-size: 0.875rem;
    }

    .content {
      padding: 24px;
    }

    /* Tab Navigation */
    .tab-header {
      background: #f7fafc;
      border-bottom: 1px solid #e2e8f0;
      padding: 0 24px;
    }

    .tab-nav {
      display: flex;
      gap: 4px;
    }

    .tab-btn {
      background: none;
      border: none;
      padding: 12px 20px;
      border-radius: 8px 8px 0 0;
      font-size: 14px;
      font-weight: 500;
      color: #64748b;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid transparent;
      border-bottom: none;
    }

    .tab-btn:hover {
      background: #e2e8f0;
      color: #334155;
    }

    .tab-btn.active {
      background: white;
      color: #1e293b;
      border: 1px solid #e2e8f0;
      border-bottom: 1px solid white;
      margin-bottom: -1px;
    }

    .tab-content {
      display: none;
      padding: 24px;
    }

    .tab-content.active {
      display: block;
    }

    /* Form Styles */
    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #374151;
    }

    #techStackInput {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
      transition: border-color 0.2s ease;
    }

    #techStackInput:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    select, input[type="text"] {
      width: 100%;
      padding: 12px;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.2s ease;
    }

    select:focus, input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      width: 100%;
    }

    .button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .button:disabled {
      background: #94a3b8;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .button-secondary {
      background: #6b7280;
      width: auto;
      padding: 8px 16px;
      font-size: 12px;
      margin-top: 8px;
    }

    /* Status and Results */
    .status-section {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }

    .confidence-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 500;
    }

    .confidence-score {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
    }

    .confidence-high { background: #dcfce7; color: #166534; }
    .confidence-medium { background: #fef3c7; color: #92400e; }
    .confidence-low { background: #fee2e2; color: #991b1b; }

    .suggestions {
      margin-top: 12px;
    }

    .suggestion-pill {
      display: inline-block;
      padding: 4px 12px;
      margin: 2px 4px 2px 0;
      background: #e0e7ff;
      color: #3730a3;
      border-radius: 20px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .suggestion-pill:hover {
      background: #c7d2fe;
    }

    #results {
      margin-top: 20px;
      padding: 20px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }

    #results.hidden {
      display: none;
    }

    #results textarea {
      width: 100%;
      min-height: 300px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      padding: 12px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 13px;
      line-height: 1.5;
      background: white;
      resize: vertical;
    }

    .error-message {
      color: #dc2626;
      font-size: 14px;
      margin-top: 8px;
      padding: 8px 12px;
      background: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: 6px;
    }

    .fallback-notice {
      background: #fff7ed;
      border: 1px solid #fed7aa;
      color: #9a3412;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 14px;
    }

    .copy-success {
      color: #059669;
      font-size: 14px;
      margin-top: 8px;
      padding: 8px 12px;
      background: #ecfdf5;
      border: 1px solid #a7f3d0;
      border-radius: 6px;
    }

    .loading {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #6b7280;
      font-size: 14px;
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #e5e7eb;
      border-top: 2px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Config Sections */
    .config-section {
      margin-bottom: 20px;
      padding: 16px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
    }

    .config-title {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 12px;
    }

    .mode-selection {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .radio-group {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .radio-group:hover {
      border-color: #d1d5db;
      background: #f9fafb;
    }

    .radio-group:has(input:checked) {
      border-color: #667eea;
      background: #f0f4ff;
    }

    .radio-group input[type="radio"] {
      margin-top: 2px;
    }

    .radio-group label {
      display: flex;
      flex-direction: column;
      gap: 4px;
      cursor: pointer;
      margin-bottom: 0;
    }

    .radio-label {
      font-weight: 600;
      color: #374151;
    }

    .radio-description {
      font-size: 12px;
      color: #6b7280;
      line-height: 1.4;
    }

    .mcp-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
    }

    .status-indicator {
      font-size: 16px;
    }

    .status-text {
      font-size: 14px;
      color: #6b7280;
    }

    /* Design Health Metrics */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 20px;
    }

    .metric-card {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 16px;
      text-align: center;
    }

    .metric-value {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    .metric-label {
      font-size: 12px;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .metric-excellent { color: #059669; }
    .metric-good { color: #0891b2; }
    .metric-fair { color: #d97706; }
    .metric-poor { color: #dc2626; }

    /* Enhanced Tech Stack Interface Styles */
    .tech-stack-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .tech-stack-title {
      font-weight: 600;
      color: #374151;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ai-powered-badge {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 10px;
      font-weight: 500;
      padding: 2px 6px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .tech-suggestions {
      margin-bottom: 16px;
    }

    .suggestions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px;
      margin-bottom: 12px;
    }

    .suggestion-pill {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
      border: 2px solid transparent;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      min-height: 36px;
    }

    .suggestion-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .suggestion-pill[data-type="react"] {
      background: linear-gradient(135deg, #61dafb20 0%, #61dafb40 100%);
      border-color: #61dafb;
      color: #0a7e95;
    }

    .suggestion-pill[data-type="vue"] {
      background: linear-gradient(135deg, #4fc08d20 0%, #4fc08d40 100%);
      border-color: #4fc08d;
      color: #2c5530;
    }

    .suggestion-pill[data-type="angular"] {
      background: linear-gradient(135deg, #dd002420 0%, #dd002440 100%);
      border-color: #dd0024;
      color: #990018;
    }

    .suggestion-pill[data-type="node"] {
      background: linear-gradient(135deg, #68a06320 0%, #68a06340 100%);
      border-color: #68a063;
      color: #3e5d3b;
    }

    .suggestion-pill[data-type="python"] {
      background: linear-gradient(135deg, #ffd43b20 0%, #4584b640 100%);
      border-color: #4584b6;
      color: #2d5aa0;
    }

    .suggestion-pill[data-type="design"] {
      background: linear-gradient(135deg, #ff6b3520 0%, #ff6b3540 100%);
      border-color: #ff6b35;
      color: #cc4a20;
    }

    .suggestion-pill[data-type="aem"] {
      background: linear-gradient(135deg, #ff000020 0%, #cc000040 100%);
      border-color: #ff0000;
      color: #cc0000;
    }

    .parse-button-container {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 12px;
    }

    .parse-tech-stack {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s ease;
    }

    .parse-tech-stack:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .parse-tech-stack:active {
      transform: translateY(0);
    }

    .confidence-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #6b7280;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .confidence-indicator.show {
      opacity: 1;
    }

    .confidence-bar {
      width: 60px;
      height: 4px;
      background: #e5e7eb;
      border-radius: 2px;
      overflow: hidden;
    }

    .confidence-fill {
      height: 100%;
      background: linear-gradient(90deg, #dc2626 0%, #f59e0b 50%, #10b981 100%);
      transition: width 0.5s ease;
      border-radius: 2px;
    }
  </style>
</head>

<body>
  <div id="app">
    <div class="header">
      <h1>Enhanced Figma Plugin</h1>
      <div class="subtitle">AI-powered ticket generation with design health insights</div>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-header">
      <div class="tab-nav">
        <button class="tab-btn active" data-tab="generator">🎫 Ticket Generator</button>
        <button class="tab-btn" data-tab="health">📊 Design Health</button>
      </div>
    </div>

    <!-- Ticket Generator Tab -->
    <div class="tab-content active" id="generator-tab">
      <div class="content">
        <div class="panel-header">
          <h2 class="panel-title">🎫 Figma to Document Generator</h2>
          <p class="panel-subtitle">Transform Figma designs into professional documents</p>
        </div>

        <!-- Generation Mode Selection -->
        <div class="config-section">
          <div class="config-title">Generation Mode</div>
          
          <div class="mode-selection">
            <div class="radio-group">
              <input type="radio" id="modeMCP" name="generationMode" value="mcp" checked>
              <label for="modeMCP">
                <span class="radio-label">🚀 MCP Server (Enhanced)</span>
                <span class="radio-description">Local Model Context Protocol server with strategic design analysis</span>
              </label>
            </div>
            
            <div class="radio-group">
              <input type="radio" id="modeOpenAI" name="generationMode" value="openai">
              <label for="modeOpenAI">
                <span class="radio-label">🤖 OpenAI API</span>
                <span class="radio-description">Cloud-based AI generation (requires API key)</span>
              </label>
            </div>
          </div>
        </div>

        <!-- OpenAI Configuration (hidden by default) -->
        <div class="config-section" id="openaiConfig" style="display: none;">
          <div class="config-title">OpenAI Configuration</div>
          
          <div class="form-group">
            <label for="apiKey">OpenAI API Key</label>
            <input type="password" id="apiKey" placeholder="sk-..." />
          </div>
          
          <div class="form-group">
            <label for="model">Model</label>
            <select id="model">
              <option value="gpt-4o-mini">GPT-4o Mini (Recommended)</option>
              <option value="gpt-4o">GPT-4o</option>
              <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
            </select>
          </div>
        </div>

        <!-- MCP Configuration (visible by default) -->
        <div class="config-section" id="mcpConfig">
          <div class="config-title">MCP Configuration</div>
          <div class="mcp-status">
            <span class="status-indicator" id="mcpStatus">🔄</span>
            <span class="status-text" id="mcpStatusText">Checking MCP server...</span>
          </div>
        </div>
        
        <div class="form-group">
          <div class="tech-stack-header">
            <h3 class="tech-stack-title">🛠️ Describe Your Tech Stack 
              <span class="ai-powered-badge">AI-Powered</span>
            </h3>
          </div>
          <p class="tech-stack-subtitle">Tell us about your project in plain English:</p>
          <textarea 
            id="techStackInput" 
            placeholder="e.g., I need a React app with TypeScript, using Material-UI for styling, Jest for testing, and I want to deploy on Vercel..."
            rows="4"></textarea>
          
          <div class="tech-suggestions">
            <p class="suggestions-label">Or try these popular combinations:</p>
            <div class="suggestions-grid">
              <div class="suggestion-pill" data-type="react">React + TypeScript + Tailwind</div>
              <div class="suggestion-pill" data-type="vue">Vue 3 + Pinia + SCSS</div>
              <div class="suggestion-pill" data-type="angular">Angular + Material</div>
              <div class="suggestion-pill" data-type="node">Node.js + Express + MongoDB</div>
              <div class="suggestion-pill" data-type="python">Python + FastAPI + PostgreSQL</div>
              <div class="suggestion-pill" data-type="aem">AEM 6.5 + HTL + Sling + OSGi</div>
              <div class="suggestion-pill" data-type="design">Figma + Design System</div>
            </div>
          </div>
          
          <div class="parse-button-container">
            <button class="parse-tech-stack">🧠 Parse Tech Stack</button>
            <div class="confidence-indicator">
              <span>Confidence:</span>
              <div class="confidence-bar">
                <div class="confidence-fill"></div>
              </div>
              <span class="confidence-text">0%</span>
            </div>
          </div>
        </div>

        <div class="form-group">
          <label for="documentType">Document Type</label>
          <select id="documentType">
            <option value="jira">Jira Ticket</option>
            <option value="confluence">Confluence Page</option>
            <option value="wiki">Wiki Documentation</option>
            <option value="agent">Agent Task</option>
          </select>
        </div>

        <div class="status-section" style="display: none;">
          <div class="confidence-indicator">
            <span>📊 Confidence:</span>
            <span class="confidence-score confidence-high">85%</span>
          </div>
          <div class="suggestions">
            <span class="suggestion-pill">Add testing framework</span>
            <span class="suggestion-pill">Specify API architecture</span>
            <span class="suggestion-pill">Include deployment strategy</span>
          </div>
        </div>

        <button id="generate" class="button">🚀 Generate Enhanced Document</button>

        <div id="results" class="hidden">
          <label>Generated Content</label>
          <textarea id="generatedContent" readonly></textarea>
          <button id="copyBtn" class="copy-btn button button-secondary">📋 Copy to Clipboard</button>
        </div>
      </div>
    </div>

    <!-- Design Health Tab -->
    <div class="tab-content" id="health-tab">
      <div class="content">
        <h2>📊 Design System Health</h2>
        <p style="color: #64748b; margin-bottom: 24px;">Monitor and improve your design system consistency</p>

        <div class="metrics-grid">
          <div class="metric-card">
            <div class="metric-value metric-excellent" id="overallScore">87%</div>
            <div class="metric-label">Overall Score</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-value metric-good" id="complianceRate">92%</div>
            <div class="metric-label">Compliance Rate</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-value metric-fair" id="componentUsage">78%</div>
            <div class="metric-label">Component Usage</div>
          </div>
          
          <div class="metric-card">
            <div class="metric-value metric-good" id="tokenAdoption">85%</div>
            <div class="metric-label">Token Adoption</div>
          </div>
        </div>

        <!-- Component Analysis -->
        <div style="background: white; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
          <h3 style="margin-bottom: 16px; color: #374151; font-size: 16px;">Component Analysis</h3>
          
          <div style="margin-bottom: 16px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="font-weight: 500;">Standard Components</span>
              <span style="background: #dcfce7; color: #166534; padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">85%</span>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="font-weight: 500;">Custom Components</span>
              <span style="background: #fef3c7; color: #92400e; padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">68%</span>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: 500;">Most Used Component</span>
              <span style="background: #dcfce7; color: #166534; padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">Button</span>
            </div>
          </div>
        </div>

        <!-- Token Adoption -->
        <div style="background: white; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
          <h3 style="margin-bottom: 16px; color: #374151; font-size: 16px;">Token Adoption</h3>
          
          <div style="margin-bottom: 16px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="font-weight: 500;">Color Tokens</span>
              <span style="background: #dcfce7; color: #166534; padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">92%</span>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="font-weight: 500;">Typography Tokens</span>
              <span style="background: #fef3c7; color: #92400e; padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">76%</span>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="font-weight: 500;">Spacing Tokens</span>
              <span style="background: #fee2e2; color: #991b1b; padding: 2px 8px; border-radius: 4px; font-size: 12px; font-weight: 600;">64%</span>
            </div>
          </div>
        </div>

        <!-- Recommendations -->
        <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 16px;">
          <h3 style="margin-bottom: 12px; color: #374151;">Recommendations</h3>
          <div id="recommendations">
            <div style="margin-bottom: 8px;">✅ <strong>Good:</strong> High color token adoption rate</div>
            <div style="margin-bottom: 8px;">⚠️ <strong>Improve:</strong> Increase spacing token consistency</div>
            <div>💡 <strong>Suggestion:</strong> Standardize typography scale usage</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    const techStackInput = document.getElementById('techStackInput');
    const documentTypeSelect = document.getElementById('documentType');
    const generateBtn = document.getElementById('generate');
    const resultsDiv = document.getElementById('results');
    const resultsTextarea = document.getElementById('generatedContent');
    const copyBtn = document.getElementById('copyBtn');
    const statusSection = document.querySelector('.status-section');

    // Tab Management
    function initializeTabs() {
      const tabBtns = document.querySelectorAll('.tab-btn');
      const tabContents = document.querySelectorAll('.tab-content');
      
      tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const targetTab = btn.dataset.tab;
          
          // Remove active class from all tabs and buttons
          tabBtns.forEach(b => b.classList.remove('active'));
          tabContents.forEach(c => c.classList.remove('active'));
          
          // Add active class to clicked button and corresponding content
          btn.classList.add('active');
          document.getElementById(`${targetTab}-tab`).classList.add('active');
        });
      });
    }

    // Mode Selection Management
    function initializeModeSelection() {
      const mcpRadio = document.getElementById('modeMCP');
      const openaiRadio = document.getElementById('modeOpenAI');
      const openaiConfig = document.getElementById('openaiConfig');
      const mcpConfig = document.getElementById('mcpConfig');
      
      function updateModeDisplay() {
        if (mcpRadio.checked) {
          openaiConfig.style.display = 'none';
          mcpConfig.style.display = 'block';
          checkMCPServer();
        } else {
          openaiConfig.style.display = 'block';
          mcpConfig.style.display = 'none';
        }
      }
      
      mcpRadio.addEventListener('change', updateModeDisplay);
      openaiRadio.addEventListener('change', updateModeDisplay);
      
      // Initialize display
      updateModeDisplay();
    }

    // Check MCP Server Status
    async function checkMCPServer() {
      const mcpStatus = document.getElementById('mcpStatus');
      const mcpStatusText = document.getElementById('mcpStatusText');
      
      try {
        mcpStatus.textContent = '🔄';
        mcpStatusText.textContent = 'Checking MCP server...';
        
        const response = await fetch('http://localhost:3000', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            jsonrpc: '2.0',
            method: 'ping',
            id: 1 
          })
        });
        
        if (response.ok) {
          mcpStatus.textContent = '✅';
          mcpStatusText.textContent = 'MCP server available';
        } else {
          throw new Error('Server responded with error');
        }
      } catch (error) {
        mcpStatus.textContent = '❌';
        mcpStatusText.textContent = 'MCP server unavailable';
        console.warn('MCP server check failed:', error);
      }
    }

    // MCP Server Communication
    async function callMCPServer(method, params) {
      try {
        console.log('🔍 Calling MCP server:', method, params);
        
        const response = await fetch('http://localhost:3000', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            method: method,
            params: params,
            id: 1
          }),
        });
        
        console.log('📡 MCP response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`MCP Server error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('📦 MCP response data:', data);
        return data.result || data;
      } catch (error) {
        console.error('❌ MCP call failed:', error);
        throw error;
      }
    }

    // Enhanced Tech stack parsing with Figma design context (Phase 1: Line Item 1.1)
    function parseTechStack(description, figmaContext = null) {
      const frameworks = ['react', 'vue', 'angular', 'svelte', 'next.js', 'nuxt', 'gatsby'];
      const languages = ['typescript', 'javascript', 'python', 'java', 'c#', 'go', 'rust'];
      const tools = ['webpack', 'vite', 'parcel', 'rollup', 'esbuild'];
      const testing = ['jest', 'vitest', 'cypress', 'playwright', 'testing-library'];
      
      const lowerDesc = description.toLowerCase();
      
      const detected = {
        frameworks: frameworks.filter(f => lowerDesc.includes(f)),
        languages: languages.filter(l => lowerDesc.includes(l)),
        tools: tools.filter(t => lowerDesc.includes(t)),
        testing: testing.filter(t => lowerDesc.includes(t))
      };
      
      // Calculate base confidence based on specificity
      let confidence = 50;
      if (detected.frameworks.length > 0) confidence += 20;
      if (detected.languages.length > 0) confidence += 15;
      if (detected.tools.length > 0) confidence += 10;
      if (detected.testing.length > 0) confidence += 5;
      if (lowerDesc.includes('version') || /\d+/.test(lowerDesc)) confidence += 10;
      
      confidence = Math.min(confidence, 95);
      
      // Generate base suggestions based on detected tech
      const suggestions = [];
      if (detected.frameworks.length > 0) {
        detected.frameworks.forEach(f => suggestions.push(f.charAt(0).toUpperCase() + f.slice(1)));
      }
      if (detected.languages.length > 0) {
        detected.languages.forEach(l => suggestions.push(l.charAt(0).toUpperCase() + l.slice(1)));
      }
      
      // Add default suggestions if none detected
      if (suggestions.length === 0) {
        suggestions.push('Add specific versions', 'Include testing framework', 'Mention state management');
      }

      // Phase 1 Enhancement: Analyze Figma design context if provided
      let designContext = null;
      let enhancedSuggestions = [...suggestions];
      
      if (figmaContext && figmaContext.layers) {
        try {
          // Phase 1 Line Item 1.1: Analyze design patterns
          const patterns = analyzeDesignPatterns(figmaContext);
          
          // Phase 1 Line Item 1.1: Detect component types
          const components = detectComponentTypes(figmaContext);
          
          // Phase 1 Line Item 1.2: Enhanced Design System Analysis
          const systemAnalysis = window.designSystemAnalyzer ? 
            window.designSystemAnalyzer.analyzeDesignSystem(figmaContext) : null;
          
          // Enhanced confidence scoring
          const designBoost = calculateDesignConfidenceBoost(detected, patterns, components);
          confidence = Math.min(confidence + designBoost, 95);
          
          // Add system analysis confidence boost
          if (systemAnalysis && systemAnalysis.confidence > 0) {
            const systemBoost = Math.round(systemAnalysis.confidence * 0.1); // 10% of system confidence
            confidence = Math.min(confidence + systemBoost, 98);
          }
          
          // Generate design-informed suggestions
          const designSuggestions = generateDesignSuggestions(detected, patterns, components);
          
          // Add design system recommendations
          if (systemAnalysis && systemAnalysis.recommendations) {
            systemAnalysis.recommendations.forEach(rec => {
              if (rec.type === 'implementation') {
                designSuggestions.push(rec.message);
              }
            });
          }
          
          enhancedSuggestions = [...suggestions, ...designSuggestions].slice(0, 6);
          
          designContext = {
            patterns,
            components,
            systemAnalysis, // Phase 1 Line Item 1.2 addition
            analysisTimestamp: new Date().toISOString(),
            enhanced: true
          };
          
          console.log('🎨 Design Context Analysis:', designContext);
        } catch (error) {
          console.warn('Design analysis failed, using base parser:', error);
          designContext = { error: error.message, enhanced: false };
        }
      }
      
      return { 
        detected, 
        confidence, 
        suggestions: enhancedSuggestions,
        designContext,
        stack: [...detected.frameworks, ...detected.languages], // Flatten for compatibility
        enhanced: designContext !== null
      };
    }

    // Phase 1: Design Pattern Analysis Functions
    function analyzeDesignPatterns(figmaContext) {
      const patterns = [];
      const layerText = extractTextFromLayers(figmaContext.layers);
      const layerNames = extractLayerNames(figmaContext.layers);
      const combinedText = (layerText + ' ' + layerNames).toLowerCase();

      // Form pattern detection
      const formIndicators = ['input', 'form', 'field', 'submit', 'button', 'login', 'register'];
      const formMatches = formIndicators.filter(indicator => combinedText.includes(indicator));
      if (formMatches.length > 0) {
        patterns.push({
          type: 'form',
          confidence: Math.min(formMatches.length / formIndicators.length, 1),
          indicators: formMatches,
          suggestedLibraries: ['react-hook-form', 'formik', 'vee-validate']
        });
      }

      // Navigation pattern detection
      const navIndicators = ['nav', 'menu', 'header', 'sidebar', 'breadcrumb', 'tab'];
      const navMatches = navIndicators.filter(indicator => combinedText.includes(indicator));
      if (navMatches.length > 0) {
        patterns.push({
          type: 'navigation',
          confidence: Math.min(navMatches.length / navIndicators.length, 1),
          indicators: navMatches,
          suggestedLibraries: ['react-router', 'vue-router', 'reach-router']
        });
      }

      // Data display pattern detection
      const dataIndicators = ['table', 'list', 'grid', 'card', 'chart', 'dashboard'];
      const dataMatches = dataIndicators.filter(indicator => combinedText.includes(indicator));
      if (dataMatches.length > 0) {
        patterns.push({
          type: 'dataDisplay',
          confidence: Math.min(dataMatches.length / dataIndicators.length, 1),
          indicators: dataMatches,
          suggestedLibraries: ['ag-grid', 'react-table', 'chart.js']
        });
      }

      return patterns;
    }

    function detectComponentTypes(figmaContext) {
      const components = [];
      
      figmaContext.layers.forEach(layer => {
        const layerName = (layer.name || '').toLowerCase();
        
        // Button detection
        if (layerName.includes('button') || layerName.includes('btn') || layerName.includes('cta')) {
          components.push({
            type: 'button',
            complexity: 'low',
            layerId: layer.id,
            layerName: layer.name,
            estimatedEffort: '1-2 hours',
            suggestedProps: ['variant', 'size', 'onClick', 'disabled']
          });
        }
        
        // Input detection
        if (layerName.includes('input') || layerName.includes('field') || layerName.includes('textfield')) {
          components.push({
            type: 'input',
            complexity: 'medium',
            layerId: layer.id,
            layerName: layer.name,
            estimatedEffort: '2-3 hours',
            suggestedProps: ['type', 'placeholder', 'value', 'onChange', 'validation']
          });
        }
        
        // Modal/Dialog detection
        if (layerName.includes('modal') || layerName.includes('dialog') || layerName.includes('popup')) {
          components.push({
            type: 'modal',
            complexity: 'high',
            layerId: layer.id,
            layerName: layer.name,
            estimatedEffort: '4-6 hours',
            suggestedProps: ['isOpen', 'onClose', 'title', 'children']
          });
        }
      });
      
      return components;
    }

    function calculateDesignConfidenceBoost(detected, patterns, components) {
      let boost = 0;
      
      // Boost based on pattern-framework alignment
      const detectedFramework = detected.frameworks[0];
      if (detectedFramework) {
        patterns.forEach(pattern => {
          if (pattern.type === 'form' && ['react', 'vue', 'angular'].includes(detectedFramework)) {
            boost += 5; // Forms work well with component frameworks
          }
          if (pattern.type === 'navigation' && detectedFramework === 'react') {
            boost += 3; // React has excellent routing libraries
          }
          if (pattern.type === 'dataDisplay' && ['react', 'angular'].includes(detectedFramework)) {
            boost += 4; // Good data handling capabilities
          }
        });
      }
      
      // Boost based on component complexity
      const complexComponents = components.filter(c => c.complexity === 'high').length;
      if (complexComponents > 0 && ['react', 'vue', 'angular'].includes(detectedFramework)) {
        boost += 3; // Advanced frameworks handle complex components better
      }
      
      return Math.min(boost, 15); // Cap the boost at 15 points
    }

    function generateDesignSuggestions(detected, patterns, components) {
      const suggestions = [];
      
      // Pattern-based suggestions
      patterns.forEach(pattern => {
        if (pattern.suggestedLibraries && pattern.suggestedLibraries.length > 0) {
          suggestions.push(`Consider ${pattern.suggestedLibraries[0]} for ${pattern.type}`);
        }
      });
      
      // Component-based suggestions
      const hasComplexComponents = components.some(c => c.complexity === 'high');
      if (hasComplexComponents) {
        suggestions.push('Add state management library');
      }
      
      const hasInputs = components.some(c => c.type === 'input');
      if (hasInputs) {
        suggestions.push('Include form validation');
      }
      
      return suggestions.slice(0, 3); // Limit to 3 design suggestions
    }

    function extractTextFromLayers(layers) {
      let text = '';
      layers.forEach(layer => {
        if (layer.type === 'TEXT' && layer.characters) {
          text += layer.characters + ' ';
        }
        if (layer.children && Array.isArray(layer.children)) {
          text += extractTextFromLayers(layer.children);
        }
      });
      return text;
    }

    function extractLayerNames(layers) {
      let names = '';
      layers.forEach(layer => {
        if (layer.name) {
          names += layer.name + ' ';
        }
        if (layer.children && Array.isArray(layer.children)) {
          names += extractLayerNames(layer.children);
        }
      });
      return names;
    }

    // Update confidence indicator
    function updateConfidenceIndicator(confidence, suggestions = []) {
      const indicator = statusSection.querySelector('.confidence-indicator');
      const scoreEl = statusSection.querySelector('.confidence-score');
      const suggestionsEl = statusSection.querySelector('.suggestions');
      
      scoreEl.textContent = `${confidence}%`;
      scoreEl.className = `confidence-score ${
        confidence >= 80 ? 'confidence-high' : 
        confidence >= 60 ? 'confidence-medium' : 'confidence-low'
      }`;
      
      suggestionsEl.innerHTML = suggestions.map(s => 
        `<span class="suggestion-pill">${s}</span>`
      ).join('');
      
      statusSection.style.display = 'flex';
    }

    // Generate content
    async function generateContent() {
      const techStackDesc = techStackInput.value.trim();
      const documentType = documentTypeSelect.value;
      const selectedMode = document.querySelector('input[name="generationMode"]:checked').value;
      
      if (!techStackDesc) {
        showError('Please describe your tech stack to generate a document.');
        return;
      }
      
      // Show loading state
      generateBtn.disabled = true;
      generateBtn.innerHTML = '<div class="spinner"></div> Generating...';
      resultsDiv.classList.remove('hidden');
      resultsTextarea.value = 'Generating enhanced content...';
      
      try {
        // Phase 1: Enhanced tech stack parsing with Figma context
        let figmaContext = null;
        
        // Try to get Figma context from MCP server if available
        if (selectedMode === 'mcp') {
          try {
            console.log('🔍 Attempting to get Figma context from MCP server...');
            figmaContext = await callMCPServer('get_figma_context', {});
            console.log('🎨 Received Figma context:', figmaContext);
          } catch (error) {
            console.warn('Could not get Figma context, using mock data for demo:', error.message);
            // Create mock Figma context for demo/testing purposes
            figmaContext = createMockFigmaContextForDemo(techStackDesc);
          }
        } else {
          // For OpenAI mode, create a simple mock context based on tech stack description
          figmaContext = createMockFigmaContextForDemo(techStackDesc);
        }
        
        // Enhanced parsing with Figma context (Phase 1 implementation)
        const parsed = parseTechStack(techStackDesc, figmaContext);
        updateConfidenceIndicator(parsed.confidence, parsed.suggestions);
        
        // Display design context analysis if available
        if (parsed.designContext && parsed.enhanced) {
          displayDesignContextAnalysis(parsed.designContext);
        }
        
        let result;
        
        if (selectedMode === 'mcp') {
          // Try MCP server with enhanced context
          try {
            result = await callMCPServer('generate_enhanced_ticket', {
              techStack: techStackDesc,
              documentType: documentType,
              confidence: parsed.confidence,
              detectedTech: parsed.detected,
              designContext: parsed.designContext, // Phase 1: Include design context
              enhancedAnalysis: parsed.enhanced
            });
          } catch (mcpError) {
            console.warn('MCP server failed, falling back to OpenAI with enhanced context:', mcpError.message);
            // Even if MCP fails, we still have our enhanced analysis
            result = await callOpenAI(techStackDesc, documentType);
            result.usedEnhancedContext = true; // Mark that we used enhanced analysis
          }
        } else {
          // Call OpenAI API (but we still used enhanced analysis)
          result = await callOpenAI(techStackDesc, documentType);
          result.usedEnhancedContext = true; // Mark that we used enhanced analysis
        }
        
        // Handle different response formats
        let content = '';
        if (result.ticket) {
          content = result.ticket;
        } else if (result.content) {
          content = result.content;
        } else if (typeof result === 'string') {
          content = result;
        } else {
          content = JSON.stringify(result, null, 2);
        }
        
        resultsTextarea.value = content;
        
        // Show success notice for enhanced analysis
        if (parsed.enhanced || result.usedEnhancedContext) {
          const successNotice = document.createElement('div');
          successNotice.className = 'enhanced-success-notice';
          successNotice.style.cssText = `
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #10b981;
            border-radius: 6px;
            padding: 12px 16px;
            margin-bottom: 16px;
            color: #065f46;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.1);
          `;
          successNotice.innerHTML = `
            <span style="font-size: 16px;">✨</span>
            <span>Phase 1 Enhanced Analysis Applied!</span>
            <span style="font-size: 12px; opacity: 0.8;">• Design patterns: ${parsed.designContext?.patterns?.length || 0} • Components: ${parsed.designContext?.components?.length || 0} • Confidence: ${parsed.confidence}%</span>
          `;
          
          resultsDiv.insertBefore(successNotice, resultsDiv.firstChild);
          
          setTimeout(() => {
            successNotice.remove();
          }, 12000);
        }
        
        // Only show fallback notice if we truly had no enhancements
        else if (result.isFallback && !parsed.enhanced) {
          showFallbackNotice();
        }
        
      } catch (error) {
        console.error('Generation failed:', error);
        resultsTextarea.value = `Error generating content: ${error.message}`;
        showError('Failed to generate content. Please try again.');
      } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = '🚀 Generate Enhanced Document';
      }
    }

    // OpenAI API Communication
    async function callOpenAI(techStack, documentType) {
      const apiKey = document.getElementById('apiKey').value.trim();
      const model = document.getElementById('model').value;
      
      if (!apiKey) {
        throw new Error('Please enter your OpenAI API key');
      }
      
      const prompt = `Create a ${documentType} for a project using this tech stack: ${techStack}`;
      
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          model: model,
          messages: [
            { 
              role: 'system', 
              content: 'You are a UX/UI ticket assistant. Generate clean, structured Jira tickets from tech stack descriptions. Focus on implementation details, acceptance criteria, and technical requirements.'
            },
            { role: 'user', content: prompt }
          ],
          max_tokens: 1500,
          temperature: 0.7
        })
      });
      
      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }
      
      const data = await response.json();
      return { 
        content: data.choices[0].message.content,
        isOpenAI: true 
      };
    }

    // Phase 1: Helper functions for enhanced Figma context
    function createMockFigmaContextForDemo(techStackDesc) {
      const lowerDesc = techStackDesc.toLowerCase();
      
      // Create enhanced context with design system elements (Phase 1 Line Item 1.2)
      const mockLayers = [];
      
      // Add design token layers for better analysis
      mockLayers.push(
        { 
          id: 'colors', 
          name: 'Color System', 
          type: 'FRAME',
          children: [
            { id: 'primary', name: 'Primary Color', type: 'RECTANGLE', fills: [{ type: 'SOLID', color: { r: 0.2, g: 0.4, b: 1.0 } }] },
            { id: 'secondary', name: 'Secondary Color', type: 'RECTANGLE', fills: [{ type: 'SOLID', color: { r: 0.8, g: 0.2, b: 0.4 } }] },
            { id: 'success', name: 'Success Color', type: 'RECTANGLE', fills: [{ type: 'SOLID', color: { r: 0.1, g: 0.8, b: 0.3 } }] }
          ]
        },
        {
          id: 'typography',
          name: 'Typography Scale',
          type: 'FRAME',
          children: [
            { id: 'h1', name: 'Heading 1', type: 'TEXT', style: { fontSize: 32, fontFamily: 'Inter', fontWeight: 700 } },
            { id: 'h2', name: 'Heading 2', type: 'TEXT', style: { fontSize: 24, fontFamily: 'Inter', fontWeight: 600 } },
            { id: 'body', name: 'Body Text', type: 'TEXT', style: { fontSize: 16, fontFamily: 'Inter', fontWeight: 400 } }
          ]
        }
      );
      
      if (lowerDesc.includes('form') || lowerDesc.includes('login') || lowerDesc.includes('register')) {
        mockLayers.push(
          { 
            id: '1', 
            name: 'Login Form', 
            type: 'FRAME',
            children: [
              { id: '1a', name: 'Email Input', type: 'TEXT', characters: 'Email Address', style: { fontSize: 16, fontFamily: 'Inter' } },
              { id: '1b', name: 'Password Input', type: 'TEXT', characters: 'Password', style: { fontSize: 16, fontFamily: 'Inter' } },
              { id: '1c', name: 'Submit Button', type: 'RECTANGLE', fills: [{ type: 'SOLID', color: { r: 0.2, g: 0.4, b: 1.0 } }] }
            ]
          }
        );
      }
      
      if (lowerDesc.includes('nav') || lowerDesc.includes('menu') || lowerDesc.includes('header')) {
        mockLayers.push(
          { 
            id: '5', 
            name: 'Main Navigation', 
            type: 'FRAME',
            children: [
              { id: '5a', name: 'Nav Logo', type: 'TEXT', characters: 'Logo', style: { fontSize: 20, fontFamily: 'Inter', fontWeight: 700 } },
              { id: '5b', name: 'Nav Menu Items', type: 'TEXT', characters: 'Home About Contact', style: { fontSize: 16, fontFamily: 'Inter' } },
              { id: '5c', name: 'Nav Button', type: 'RECTANGLE', fills: [{ type: 'SOLID', color: { r: 0.2, g: 0.4, b: 1.0 } }] }
            ]
          }
        );
      }
      
      if (lowerDesc.includes('table') || lowerDesc.includes('list') || lowerDesc.includes('data')) {
        mockLayers.push(
          { 
            id: '8', 
            name: 'Data Table', 
            type: 'FRAME',
            children: [
              { id: '8a', name: 'Table Header', type: 'TEXT', characters: 'Name Email Role', style: { fontSize: 14, fontFamily: 'Inter', fontWeight: 600 } },
              { id: '8b', name: 'Table Row', type: 'FRAME' },
              { id: '8c', name: 'Table Cell', type: 'TEXT', characters: 'Data', style: { fontSize: 14, fontFamily: 'Inter' } }
            ]
          }
        );
      }
      
      if (lowerDesc.includes('card') || lowerDesc.includes('product')) {
        mockLayers.push(
          { id: '11', name: 'Product Card', type: 'FRAME' },
          { id: '12', name: 'Card Title', type: 'TEXT', characters: 'Product Name' },
          { id: '13', name: 'Card Button', type: 'RECTANGLE' }
        );
      }
      
      // Default generic components if nothing specific detected
      if (mockLayers.length === 0) {
        mockLayers.push(
          { id: '1', name: 'Main Component', type: 'FRAME' },
          { id: '2', name: 'Action Button', type: 'RECTANGLE' },
          { id: '3', name: 'Content Text', type: 'TEXT', characters: 'Main content' }
        );
      }
      
      return {
        layers: mockLayers,
        source: 'mock-demo',
        timestamp: new Date().toISOString()
      };
    }

    function displayDesignContextAnalysis(designContext) {
      // Remove existing design analysis display
      const existingAnalysis = document.getElementById('design-analysis');
      if (existingAnalysis) {
        existingAnalysis.remove();
      }
      
      // Create design analysis display
      const analysisDiv = document.createElement('div');
      analysisDiv.id = 'design-analysis';
      analysisDiv.style.cssText = `
        margin-top: 16px;
        padding: 16px;
        background: linear-gradient(135deg, #f0f4ff 0%, #e0e7ff 100%);
        border: 1px solid #c7d2fe;
        border-radius: 8px;
        font-size: 14px;
      `;
      
      let analysisHTML = '<h4 style="margin: 0 0 12px 0; color: #3730a3;">🎨 Enhanced Design Analysis (Phase 1)</h4>';
      
      if (designContext.patterns && designContext.patterns.length > 0) {
        analysisHTML += '<div style="margin-bottom: 12px;"><strong>🔍 Design Patterns:</strong><ul style="margin: 4px 0; padding-left: 20px;">';
        designContext.patterns.forEach(pattern => {
          const confidence = Math.round(pattern.confidence * 100);
          analysisHTML += `<li>${pattern.type} (${confidence}% confidence) - ${pattern.indicators.join(', ')}</li>`;
        });
        analysisHTML += '</ul></div>';
      }
      
      if (designContext.components && designContext.components.length > 0) {
        analysisHTML += '<div style="margin-bottom: 12px;"><strong>🧩 Component Types:</strong><ul style="margin: 4px 0; padding-left: 20px;">';
        designContext.components.forEach(component => {
          analysisHTML += `<li>${component.type} (${component.complexity} complexity) - ${component.estimatedEffort}</li>`;
        });
        analysisHTML += '</ul></div>';
      }
      
      // Phase 1 Line Item 1.2: Display Design System Analysis
      if (designContext.systemAnalysis && designContext.systemAnalysis.confidence > 0) {
        const sysAnalysis = designContext.systemAnalysis;
        analysisHTML += '<div style="margin-bottom: 12px; padding: 8px; background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; border-radius: 4px;">';
        analysisHTML += `<strong>🏗️ Design System Analysis (${sysAnalysis.confidence}% confidence):</strong>`;
        
        // Component hierarchy
        const hierarchy = sysAnalysis.componentHierarchy;
        if (Object.values(hierarchy).some(level => level.length > 0)) {
          analysisHTML += '<div style="margin: 6px 0; font-size: 13px;">Atomic Design Levels: ';
          const levels = [];
          if (hierarchy.atoms.length > 0) levels.push(`${hierarchy.atoms.length} atoms`);
          if (hierarchy.molecules.length > 0) levels.push(`${hierarchy.molecules.length} molecules`);
          if (hierarchy.organisms.length > 0) levels.push(`${hierarchy.organisms.length} organisms`);
          if (hierarchy.templates.length > 0) levels.push(`${hierarchy.templates.length} templates`);
          analysisHTML += levels.join(', ') + '</div>';
        }
        
        // Design tokens
        if (sysAnalysis.designTokens.colors.length > 0) {
          analysisHTML += `<div style="margin: 6px 0; font-size: 13px;">Design Tokens: ${sysAnalysis.designTokens.colors.length} colors, ${sysAnalysis.designTokens.typography.length} typography styles</div>`;
        }
        
        // System consistency
        if (sysAnalysis.systemConsistency.overallScore > 0) {
          analysisHTML += `<div style="margin: 6px 0; font-size: 13px;">Consistency Score: ${sysAnalysis.systemConsistency.overallScore}%</div>`;
        }
        
        // Recommendations
        if (sysAnalysis.recommendations.length > 0) {
          analysisHTML += '<div style="margin: 6px 0; font-size: 13px;"><strong>Recommendations:</strong><ul style="margin: 2px 0; padding-left: 16px;">';
          sysAnalysis.recommendations.slice(0, 2).forEach(rec => {
            analysisHTML += `<li style="margin: 2px 0;">${rec.message} (${rec.priority} priority)</li>`;
          });
          analysisHTML += '</ul></div>';
        }
        
        analysisHTML += '</div>';
      }
      
      analysisHTML += '<div style="font-size: 12px; color: #6b7280; margin-top: 12px;">✨ Phase 1 enhanced analysis with design system evaluation</div>';
      
      analysisDiv.innerHTML = analysisHTML;
      
      // Insert after the status section
      const statusSection = document.querySelector('.status-section');
      if (statusSection && statusSection.parentNode) {
        statusSection.parentNode.insertBefore(analysisDiv, statusSection.nextSibling);
      }
    }

    // Show error message
    function showError(message) {
      // Remove existing error messages
      document.querySelectorAll('.error-message').forEach(el => el.remove());
      
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-message';
      errorDiv.textContent = message;
      
      techStackInput.parentNode.appendChild(errorDiv);
      
      setTimeout(() => {
        errorDiv.remove();
      }, 5000);
    }

    // Show fallback notice
    function showFallbackNotice() {
      const notice = document.createElement('div');
      notice.className = 'fallback-notice';
      notice.innerHTML = '⚠️ Enhanced analysis temporarily unavailable - using fallback generation';
      
      resultsDiv.insertBefore(notice, resultsDiv.firstChild);
      
      setTimeout(() => {
        notice.remove();
      }, 8000);
    }

    // Copy to clipboard
    function copyToClipboard() {
      resultsTextarea.select();
      resultsTextarea.setSelectionRange(0, 99999);
      
      try {
        document.execCommand('copy');
        copyBtn.textContent = '✅ Copied!';
        
        // Show copy success message
        const successDiv = document.createElement('div');
        successDiv.className = 'copy-success';
        successDiv.textContent = 'Content copied to clipboard successfully!';
        resultsDiv.appendChild(successDiv);
        
        setTimeout(() => {
          copyBtn.textContent = '📋 Copy to Clipboard';
          successDiv.remove();
        }, 2000);
      } catch (err) {
        console.error('Copy failed:', err);
        copyBtn.textContent = '❌ Copy failed';
        setTimeout(() => {
          copyBtn.textContent = '📋 Copy to Clipboard';
        }, 2000);
      }
    }

    // Update design health metrics (placeholder)
    function updateDesignHealth() {
      document.getElementById('overallScore').textContent = '87%';
      document.getElementById('complianceRate').textContent = '92%';
      document.getElementById('componentUsage').textContent = '78%';
      document.getElementById('tokenAdoption').textContent = '85%';
      
      document.getElementById('recommendations').innerHTML = `
        <div style="margin-bottom: 8px;">✅ <strong>Good:</strong> High token adoption rate</div>
        <div style="margin-bottom: 8px;">⚠️ <strong>Improve:</strong> Increase component reuse in navigation areas</div>
        <div>💡 <strong>Suggestion:</strong> Consider standardizing button variants</div>
      `;
    }

    // Event listeners
    generateBtn.addEventListener('click', generateContent);
    copyBtn.addEventListener('click', copyToClipboard);
    
    // Tech stack input validation and suggestions
    techStackInput.addEventListener('input', () => {
      const techStack = parseTechStack(techStackInput.value);
      if (techStackInput.value.length > 20) {
        updateConfidenceIndicator(techStack.confidence, techStack.suggestions);
      } else {
        statusSection.style.display = 'none';
      }
    });

    // Enhanced tech stack interface event listeners
    const suggestionPills = document.querySelectorAll('.suggestion-pill');
    suggestionPills.forEach(pill => {
      pill.addEventListener('click', () => {
        const techStack = pill.textContent.trim();
        techStackInput.value = techStack;
        
        // Trigger the parse analysis
        const parsed = parseTechStack(techStack);
        updateConfidenceIndicator(parsed.confidence, parsed.suggestions);
        
        // Visual feedback
        pill.style.transform = 'scale(0.95)';
        setTimeout(() => {
          pill.style.transform = '';
        }, 150);
      });
    });

    // Parse tech stack button functionality
    const parseButton = document.querySelector('.parse-tech-stack');
    if (parseButton) {
      parseButton.addEventListener('click', () => {
        const techStackValue = techStackInput.value.trim();
        if (!techStackValue) {
          techStackInput.focus();
          techStackInput.style.borderColor = '#f59e0b';
          setTimeout(() => {
            techStackInput.style.borderColor = '';
          }, 1000);
          return;
        }

        // Show loading state
        parseButton.innerHTML = '<span>🧠</span> Analyzing...';
        parseButton.disabled = true;

        // Phase 1: Enhanced AI analysis with Figma context simulation
        setTimeout(() => {
          // Create mock Figma context for enhanced analysis demo
          const mockFigmaContext = createMockFigmaContextForDemo(techStackValue);
          
          // Enhanced parsing with Figma context (Phase 1 implementation)
          const parsed = parseTechStack(techStackValue, mockFigmaContext);
          updateConfidenceIndicator(parsed.confidence, parsed.suggestions);
          
          // Display design context analysis if enhanced
          if (parsed.designContext && parsed.enhanced) {
            displayDesignContextAnalysis(parsed.designContext);
          }
          
          // Reset button
          parseButton.innerHTML = '<span>🧠</span> Parse Tech Stack';
          parseButton.disabled = false;
          
          // Show success feedback with enhancement indicator
          const indicator = document.querySelector('.confidence-indicator');
          if (indicator) {
            indicator.style.background = '#f0fdf4';
            indicator.style.padding = '8px 12px';
            indicator.style.borderRadius = '6px';
            indicator.style.border = '1px solid #bbf7d0';
            setTimeout(() => {
              indicator.style.background = '';
              indicator.style.padding = '';
              indicator.style.borderRadius = '';
              indicator.style.border = '';
            }, 2000);
          }
          
          // Enhanced parsing completion indicator
          if (parsed.enhanced) {
            console.log('✨ Enhanced tech stack analysis with Figma context completed');
            console.log('📊 Design patterns detected:', parsed.designContext?.patterns || []);
            console.log('🧩 Component types identified:', parsed.designContext?.componentTypes || []);
          }
          
          // Auto-focus next relevant field after successful parsing
          const nextInput = document.querySelector('input[placeholder*="component"], textarea[placeholder*="description"]');
          if (nextInput) {
            setTimeout(() => nextInput.focus(), 500);
          }
        }, 1500);
      });
    }

    // Initialize the application
    initializeTabs();
    initializeModeSelection();
    updateDesignHealth();

    console.log('🎯 Enhanced Figma Plugin loaded successfully');
  </script>

  <!-- Phase 1 Line Item 1.2: Design System Analyzer -->
  <script>
    /**
     * Phase 1 Line Item 1.2: Enhanced Design System Analysis
     * Embedded version of the design system analyzer for browser use
     */
    class DesignSystemAnalyzer {
      constructor() {
        this.designTokens = new Map();
        this.componentLibrary = new Map();
        this.designPatterns = [];
        this.consistencyRules = [];
      }

      analyzeDesignSystem(figmaContext) {
        if (!figmaContext || !figmaContext.layers) {
          return this.createEmptyAnalysis();
        }

        const analysis = {
          designTokens: this.extractDesignTokens(figmaContext),
          componentHierarchy: this.buildComponentHierarchy(figmaContext),
          designPatterns: this.identifyDesignPatterns(figmaContext),
          systemConsistency: this.evaluateConsistency(figmaContext),
          recommendations: [],
          confidence: 0
        };

        analysis.recommendations = this.generateSystemRecommendations(analysis);
        analysis.confidence = this.calculateSystemConfidence(analysis);

        return analysis;
      }

      extractDesignTokens(figmaContext) {
        const tokens = {
          colors: new Set(),
          typography: new Set(),
          spacing: new Set()
        };

        const layers = figmaContext.layers || [];
        
        layers.forEach(layer => {
          if (layer.fills && Array.isArray(layer.fills)) {
            layer.fills.forEach(fill => {
              if (fill.type === 'SOLID' && fill.color) {
                tokens.colors.add(this.colorToHex(fill.color));
              }
            });
          }

          if (layer.type === 'TEXT' && layer.style) {
            const typographyToken = {
              fontSize: layer.style.fontSize || 16,
              fontFamily: layer.style.fontFamily || 'Default',
              fontWeight: layer.style.fontWeight || 400
            };
            tokens.typography.add(JSON.stringify(typographyToken));
          }

          if (layer.children && Array.isArray(layer.children)) {
            const childTokens = this.extractDesignTokens({ layers: layer.children });
            this.mergeTokens(tokens, childTokens);
          }
        });

        return this.convertTokenSetsToArrays(tokens);
      }

      buildComponentHierarchy(figmaContext) {
        const hierarchy = {
          atoms: [],
          molecules: [],
          organisms: [],
          templates: []
        };

        const layers = figmaContext.layers || [];
        
        layers.forEach(layer => {
          const component = this.classifyComponent(layer);
          if (component) {
            hierarchy[component.level].push(component);
          }
        });

        return hierarchy;
      }

      classifyComponent(layer) {
        if (!layer.name) return null;

        const name = layer.name.toLowerCase();
        const hasChildren = layer.children && layer.children.length > 0;
        const childCount = hasChildren ? layer.children.length : 0;

        if (this.isAtomicComponent(name, layer)) {
          return {
            level: 'atoms',
            name: layer.name,
            type: this.getAtomicType(name),
            layerId: layer.id,
            complexity: 'low',
            estimatedEffort: '30-60 minutes'
          };
        }

        if (childCount >= 2 && childCount <= 5 && this.isMolecularComponent(name)) {
          return {
            level: 'molecules',
            name: layer.name,
            type: this.getMolecularType(name),
            layerId: layer.id,
            complexity: 'medium',
            estimatedEffort: '1-3 hours'
          };
        }

        if (childCount >= 6 && this.isOrganismalComponent(name)) {
          return {
            level: 'organisms',
            name: layer.name,
            type: this.getOrganismalType(name),
            layerId: layer.id,
            complexity: 'high',
            estimatedEffort: '4-8 hours'
          };
        }

        if (this.isTemplateComponent(name, layer)) {
          return {
            level: 'templates',
            name: layer.name,
            type: 'layout-template',
            layerId: layer.id,
            complexity: 'high',
            estimatedEffort: '6-12 hours'
          };
        }

        return null;
      }

      identifyDesignPatterns(figmaContext) {
        const patterns = [];
        const layers = figmaContext.layers || [];
        
        patterns.push(...this.detectNavigationPatterns(layers));
        patterns.push(...this.detectFormPatterns(layers));
        patterns.push(...this.detectDataPatterns(layers));

        return patterns;
      }

      detectNavigationPatterns(layers) {
        const patterns = [];
        const navLayers = layers.filter(layer => 
          layer.name && (
            layer.name.toLowerCase().includes('nav') ||
            layer.name.toLowerCase().includes('menu') ||
            layer.name.toLowerCase().includes('header')
          )
        );

        if (navLayers.length > 0) {
          patterns.push({
            category: 'navigation',
            type: 'primary-navigation',
            confidence: 85,
            recommendations: ['Implement responsive navigation', 'Add keyboard support']
          });
        }

        return patterns;
      }

      detectFormPatterns(layers) {
        const patterns = [];
        const formLayers = layers.filter(layer => 
          layer.name && (
            layer.name.toLowerCase().includes('form') ||
            layer.name.toLowerCase().includes('input') ||
            layer.name.toLowerCase().includes('field')
          )
        );

        if (formLayers.length >= 2) {
          patterns.push({
            category: 'forms',
            type: 'form-collection',
            confidence: 80,
            recommendations: ['Add form validation', 'Implement error handling']
          });
        }

        return patterns;
      }

      detectDataPatterns(layers) {
        const patterns = [];
        const dataLayers = layers.filter(layer => 
          layer.name && (
            layer.name.toLowerCase().includes('table') ||
            layer.name.toLowerCase().includes('list') ||
            layer.name.toLowerCase().includes('data')
          )
        );

        if (dataLayers.length > 0) {
          patterns.push({
            category: 'data-display',
            type: 'data-visualization',
            confidence: 75,
            recommendations: ['Add sorting/filtering', 'Implement pagination']
          });
        }

        return patterns;
      }

      evaluateConsistency(figmaContext) {
        const tokens = this.extractDesignTokens(figmaContext);
        
        return {
          colorConsistency: this.evaluateColorConsistency(tokens.colors),
          typographyConsistency: this.evaluateTypographyConsistency(tokens.typography),
          overallScore: Math.round((this.evaluateColorConsistency(tokens.colors) + this.evaluateTypographyConsistency(tokens.typography)) / 2)
        };
      }

      generateSystemRecommendations(analysis) {
        const recommendations = [];

        if (analysis.designTokens.colors.length > 12) {
          recommendations.push({
            type: 'design-tokens',
            priority: 'high',
            message: 'Consider consolidating color palette',
            action: 'Create semantic color tokens'
          });
        }

        if (analysis.systemConsistency.overallScore < 70) {
          recommendations.push({
            type: 'consistency',
            priority: 'high', 
            message: 'Low consistency score detected',
            action: 'Standardize design tokens'
          });
        }

        return recommendations.slice(0, 3);
      }

      // Helper methods
      isAtomicComponent(name, layer) {
        const atomicKeywords = ['button', 'input', 'icon', 'label', 'avatar'];
        return atomicKeywords.some(keyword => name.includes(keyword)) && 
               (!layer.children || layer.children.length <= 1);
      }

      isMolecularComponent(name) {
        const molecularKeywords = ['field', 'item', 'nav-item'];
        return molecularKeywords.some(keyword => name.includes(keyword));
      }

      isOrganismalComponent(name) {
        const organismalKeywords = ['header', 'form', 'table', 'list'];
        return organismalKeywords.some(keyword => name.includes(keyword));
      }

      isTemplateComponent(name, layer) {
        const templateKeywords = ['page', 'layout', 'template'];
        return templateKeywords.some(keyword => name.includes(keyword)) ||
               (layer.children && layer.children.length >= 10);
      }

      getAtomicType(name) {
        if (name.includes('button')) return 'button';
        if (name.includes('input')) return 'input';
        if (name.includes('icon')) return 'icon';
        return 'element';
      }

      getMolecularType(name) {
        if (name.includes('field')) return 'form-field';
        if (name.includes('item')) return 'list-item';
        return 'combination';
      }

      getOrganismalType(name) {
        if (name.includes('header')) return 'page-header';
        if (name.includes('form')) return 'form-section';
        if (name.includes('table')) return 'data-table';
        return 'complex-component';
      }

      evaluateColorConsistency(colors) {
        if (colors.length <= 8) return 90;
        if (colors.length <= 12) return 75;
        return 50;
      }

      evaluateTypographyConsistency(typography) {
        const uniqueStyles = new Set(typography);
        if (uniqueStyles.size <= 6) return 90;
        if (uniqueStyles.size <= 10) return 75;
        return 50;
      }

      colorToHex(color) {
        if (typeof color === 'string') return color;
        if (color.r !== undefined) {
          const r = Math.round(color.r * 255);
          const g = Math.round(color.g * 255);
          const b = Math.round(color.b * 255);
          return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        return '#000000';
      }

      mergeTokens(target, source) {
        Object.keys(source).forEach(key => {
          if (source[key] instanceof Set) {
            source[key].forEach(value => target[key].add(value));
          }
        });
      }

      convertTokenSetsToArrays(tokens) {
        const result = {};
        Object.keys(tokens).forEach(key => {
          result[key] = Array.from(tokens[key]);
        });
        return result;
      }

      calculateSystemConfidence(analysis) {
        let confidence = 0;
        let factors = 0;

        if (analysis.designTokens.colors.length > 0) {
          confidence += analysis.systemConsistency.colorConsistency;
          factors++;
        }

        const hierarchyLevels = Object.values(analysis.componentHierarchy)
          .filter(level => level.length > 0).length;
        confidence += (hierarchyLevels / 4) * 100;
        factors++;

        if (analysis.designPatterns.length > 0) {
          const avgPatternConfidence = analysis.designPatterns
            .reduce((sum, pattern) => sum + pattern.confidence, 0) / analysis.designPatterns.length;
          confidence += avgPatternConfidence;
          factors++;
        }

        return factors > 0 ? Math.round(confidence / factors) : 0;
      }

      createEmptyAnalysis() {
        return {
          designTokens: { colors: [], typography: [], spacing: [] },
          componentHierarchy: { atoms: [], molecules: [], organisms: [], templates: [] },
          designPatterns: [],
          systemConsistency: { colorConsistency: 0, typographyConsistency: 0, overallScore: 0 },
          recommendations: [],
          confidence: 0
        };
      }
    }

    // Initialize global design system analyzer
    window.designSystemAnalyzer = new DesignSystemAnalyzer();
    console.log('🎨 Phase 1 Line Item 1.2: Design System Analyzer loaded');
  </script>
</body>
</html>