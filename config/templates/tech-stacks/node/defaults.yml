meta:
  tech_stack: node
  version: 1.0.0
  last_updated: 2025-10-30
  status: stable

standards:
  overview:
    name: "Node.js Technology Stack"
    description: "Modern Node.js backend development with TypeScript, Express, and best practices"
    approach: "API-first development with microservices architecture and robust error handling"
    
  core_technologies:
    runtime: "Node.js 18+ LTS"
    language: "TypeScript"
    framework: "Express.js"
    package_manager: "npm"
    
  database_stack:
    primary: "PostgreSQL"
    secondary: "MongoDB"
    orm: "Prisma / TypeORM"
    cache: "Redis"
    
  testing_stack:
    unit_testing: "Jest"
    integration_testing: "Supertest"
    e2e_testing: "Playwright"
    mocking: "Jest Mocks / MSW"
    
  development_tools:
    code_quality: "ESLint + Prettier"
    type_checking: "TypeScript"
    api_docs: "OpenAPI/Swagger"
    monitoring: "Winston (logging)"
    
  security_stack:
    authentication: "JWT / Passport.js"
    authorization: "RBAC / ABAC"
    validation: "Joi / Zod"
    security_headers: "Helmet.js"
    
  project_structure:
    controllers: "src/controllers/"
    services: "src/services/"
    models: "src/models/"
    middleware: "src/middleware/"
    routes: "src/routes/"
    utils: "src/utils/"
    types: "src/types/"
    config: "src/config/"
    
  naming_conventions:
    files: "kebab-case (user-service.ts)"
    classes: "PascalCase (UserService)"
    functions: "camelCase (getUserById)"
    constants: "UPPER_SNAKE_CASE"
    endpoints: "REST conventions (/api/v1/users)"

# Service Templates
service_template:
  express_service: |
    import express from 'express';
    import { Request, Response, NextFunction } from 'express';
    import { {{ figma.component_name }}Service } from '../services/{{ figma.component_name | kebabCase }}-service';
    import { Create{{ figma.component_name }}Request, Update{{ figma.component_name }}Request } from '../types/{{ figma.component_name | kebabCase }}-types';
    import { validateRequest } from '../middleware/validation';
    import { authenticate } from '../middleware/auth';
    import { {{ figma.component_name | kebabCase }}Schema } from '../schemas/{{ figma.component_name | kebabCase }}-schema';
    
    export class {{ figma.component_name }}Controller {
      private {{ figma.component_name | camelCase }}Service: {{ figma.component_name }}Service;
      
      constructor() {
        this.{{ figma.component_name | camelCase }}Service = new {{ figma.component_name }}Service();
      }
      
      // GET /api/v1/{{ figma.component_name | kebabCase }}
      public getAll = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
          const { page = 1, limit = 20, search } = req.query;
          
          const result = await this.{{ figma.component_name | camelCase }}Service.findMany({
            page: Number(page),
            limit: Number(limit),
            search: search as string
          });
          
          res.status(200).json({
            success: true,
            data: result.items,
            pagination: {
              page: result.page,
              limit: result.limit,
              total: result.total,
              pages: Math.ceil(result.total / result.limit)
            }
          });
        } catch (error) {
          next(error);
        }
      };
      
      // GET /api/v1/{{ figma.component_name | kebabCase }}/:id
      public getById = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
          const { id } = req.params;
          
          const item = await this.{{ figma.component_name | camelCase }}Service.findById(id);
          
          if (!item) {
            res.status(404).json({
              success: false,
              error: {
                code: 'NOT_FOUND',
                message: '{{ figma.component_name }} not found'
              }
            });
            return;
          }
          
          res.status(200).json({
            success: true,
            data: item
          });
        } catch (error) {
          next(error);
        }
      };
      
      // POST /api/v1/{{ figma.component_name | kebabCase }}
      public create = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
          const data: Create{{ figma.component_name }}Request = req.body;
          
          const item = await this.{{ figma.component_name | camelCase }}Service.create(data);
          
          res.status(201).json({
            success: true,
            data: item
          });
        } catch (error) {
          next(error);
        }
      };
      
      // PUT /api/v1/{{ figma.component_name | kebabCase }}/:id
      public update = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
          const { id } = req.params;
          const data: Update{{ figma.component_name }}Request = req.body;
          
          const item = await this.{{ figma.component_name | camelCase }}Service.update(id, data);
          
          res.status(200).json({
            success: true,
            data: item
          });
        } catch (error) {
          next(error);
        }
      };
      
      // DELETE /api/v1/{{ figma.component_name | kebabCase }}/:id
      public delete = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
        try {
          const { id } = req.params;
          
          await this.{{ figma.component_name | camelCase }}Service.delete(id);
          
          res.status(204).send();
        } catch (error) {
          next(error);
        }
      };
    }
    
    // Routes setup
    export const {{ figma.component_name | camelCase }}Routes = express.Router();
    const controller = new {{ figma.component_name }}Controller();
    
    {{ figma.component_name | camelCase }}Routes.get('/', authenticate, controller.getAll);
    {{ figma.component_name | camelCase }}Routes.get('/:id', authenticate, controller.getById);
    {{ figma.component_name | camelCase }}Routes.post('/', authenticate, validateRequest({{ figma.component_name | kebabCase }}Schema.create), controller.create);
    {{ figma.component_name | camelCase }}Routes.put('/:id', authenticate, validateRequest({{ figma.component_name | kebabCase }}Schema.update), controller.update);
    {{ figma.component_name | camelCase }}Routes.delete('/:id', authenticate, controller.delete);
    
  service_layer: |
    import { {{ figma.component_name }} } from '../models/{{ figma.component_name | kebabCase }}-model';
    import { Create{{ figma.component_name }}Request, Update{{ figma.component_name }}Request, FindManyOptions } from '../types/{{ figma.component_name | kebabCase }}-types';
    import { DatabaseService } from './database-service';
    import { Logger } from '../utils/logger';
    
    export class {{ figma.component_name }}Service {
      private db: DatabaseService;
      private logger: Logger;
      
      constructor() {
        this.db = DatabaseService.getInstance();
        this.logger = new Logger('{{ figma.component_name }}Service');
      }
      
      async findMany(options: FindManyOptions) {
        try {
          this.logger.info('Finding {{ figma.component_name | kebabCase }} items', { options });
          
          const query = this.buildQuery(options);
          const [items, total] = await Promise.all([
            this.db.{{ figma.component_name | camelCase }}.findMany(query),
            this.db.{{ figma.component_name | camelCase }}.count({ where: query.where })
          ]);
          
          return {
            items,
            total,
            page: options.page,
            limit: options.limit
          };
        } catch (error) {
          this.logger.error('Error finding {{ figma.component_name | kebabCase }} items', { error, options });
          throw error;
        }
      }
      
      async findById(id: string): Promise<{{ figma.component_name }} | null> {
        try {
          this.logger.info('Finding {{ figma.component_name | kebabCase }} by ID', { id });
          
          const item = await this.db.{{ figma.component_name | camelCase }}.findUnique({
            where: { id }
          });
          
          return item;
        } catch (error) {
          this.logger.error('Error finding {{ figma.component_name | kebabCase }} by ID', { error, id });
          throw error;
        }
      }
      
      async create(data: Create{{ figma.component_name }}Request): Promise<{{ figma.component_name }}> {
        try {
          this.logger.info('Creating {{ figma.component_name | kebabCase }}', { data });
          
          const item = await this.db.{{ figma.component_name | camelCase }}.create({
            data: {
              ...data,
              createdAt: new Date(),
              updatedAt: new Date()
            }
          });
          
          this.logger.info('{{ figma.component_name }} created successfully', { id: item.id });
          return item;
        } catch (error) {
          this.logger.error('Error creating {{ figma.component_name | kebabCase }}', { error, data });
          throw error;
        }
      }
      
      async update(id: string, data: Update{{ figma.component_name }}Request): Promise<{{ figma.component_name }}> {
        try {
          this.logger.info('Updating {{ figma.component_name | kebabCase }}', { id, data });
          
          const item = await this.db.{{ figma.component_name | camelCase }}.update({
            where: { id },
            data: {
              ...data,
              updatedAt: new Date()
            }
          });
          
          this.logger.info('{{ figma.component_name }} updated successfully', { id });
          return item;
        } catch (error) {
          this.logger.error('Error updating {{ figma.component_name | kebabCase }}', { error, id, data });
          throw error;
        }
      }
      
      async delete(id: string): Promise<void> {
        try {
          this.logger.info('Deleting {{ figma.component_name | kebabCase }}', { id });
          
          await this.db.{{ figma.component_name | camelCase }}.delete({
            where: { id }
          });
          
          this.logger.info('{{ figma.component_name }} deleted successfully', { id });
        } catch (error) {
          this.logger.error('Error deleting {{ figma.component_name | kebabCase }}', { error, id });
          throw error;
        }
      }
      
      private buildQuery(options: FindManyOptions) {
        const { page, limit, search } = options;
        
        return {
          where: search ? {
            OR: [
              { name: { contains: search, mode: 'insensitive' } },
              { description: { contains: search, mode: 'insensitive' } }
            ]
          } : {},
          skip: (page - 1) * limit,
          take: limit,
          orderBy: { createdAt: 'desc' }
        };
      }
    }
    
  service_test: |
    import request from 'supertest';
    import { app } from '../app';
    import { DatabaseService } from '../services/database-service';
    import { {{ figma.component_name }}Service } from '../services/{{ figma.component_name | kebabCase }}-service';
    
    describe('{{ figma.component_name }} API', () => {
      let service: {{ figma.component_name }}Service;
      let authToken: string;
      
      beforeAll(async () => {
        service = new {{ figma.component_name }}Service();
        
        // Setup test authentication
        const authResponse = await request(app)
          .post('/api/v1/auth/login')
          .send({
            email: 'test@example.com',
            password: 'testpassword'
          });
        
        authToken = authResponse.body.token;
      });
      
      beforeEach(async () => {
        // Clean up test data
        await DatabaseService.getInstance().{{ figma.component_name | camelCase }}.deleteMany({
          where: { name: { startsWith: 'test-' } }
        });
      });
      
      describe('GET /api/v1/{{ figma.component_name | kebabCase }}', () => {
        it('should return paginated results', async () => {
          // Create test data
          await service.create({
            name: 'test-item-1',
            description: 'Test description 1'
          });
          
          const response = await request(app)
            .get('/api/v1/{{ figma.component_name | kebabCase }}')
            .set('Authorization', `Bearer ${authToken}`)
            .expect(200);
          
          expect(response.body.success).toBe(true);
          expect(response.body.data).toBeInstanceOf(Array);
          expect(response.body.pagination).toBeDefined();
        });
        
        it('should filter by search query', async () => {
          await service.create({
            name: 'test-searchable-item',
            description: 'This is searchable'
          });
          
          const response = await request(app)
            .get('/api/v1/{{ figma.component_name | kebabCase }}?search=searchable')
            .set('Authorization', `Bearer ${authToken}`)
            .expect(200);
          
          expect(response.body.data.length).toBeGreaterThan(0);
          expect(response.body.data[0].name).toContain('searchable');
        });
      });
      
      describe('POST /api/v1/{{ figma.component_name | kebabCase }}', () => {
        it('should create a new item', async () => {
          const newItem = {
            name: 'test-new-item',
            description: 'Test description'
          };
          
          const response = await request(app)
            .post('/api/v1/{{ figma.component_name | kebabCase }}')
            .set('Authorization', `Bearer ${authToken}`)
            .send(newItem)
            .expect(201);
          
          expect(response.body.success).toBe(true);
          expect(response.body.data.name).toBe(newItem.name);
        });
        
        it('should validate required fields', async () => {
          const response = await request(app)
            .post('/api/v1/{{ figma.component_name | kebabCase }}')
            .set('Authorization', `Bearer ${authToken}`)
            .send({})
            .expect(400);
          
          expect(response.body.success).toBe(false);
          expect(response.body.error.code).toBe('VALIDATION_ERROR');
        });
      });
      
      describe('GET /api/v1/{{ figma.component_name | kebabCase }}/:id', () => {
        it('should return item by ID', async () => {
          const item = await service.create({
            name: 'test-item',
            description: 'Test description'
          });
          
          const response = await request(app)
            .get(`/api/v1/{{ figma.component_name | kebabCase }}/${item.id}`)
            .set('Authorization', `Bearer ${authToken}`)
            .expect(200);
          
          expect(response.body.success).toBe(true);
          expect(response.body.data.id).toBe(item.id);
        });
        
        it('should return 404 for non-existent item', async () => {
          const response = await request(app)
            .get('/api/v1/{{ figma.component_name | kebabCase }}/non-existent-id')
            .set('Authorization', `Bearer ${authToken}`)
            .expect(404);
          
          expect(response.body.success).toBe(false);
          expect(response.body.error.code).toBe('NOT_FOUND');
        });
      });
    });

# Type Definitions
type_template:
  request_types: |
    // {{ figma.component_name | kebabCase }}-types.ts
    
    export interface {{ figma.component_name }} {
      id: string;
      name: string;
      description?: string;
      status: 'active' | 'inactive';
      createdAt: Date;
      updatedAt: Date;
    {% for prop in figma.properties %}
      {{ prop.name }}{{ prop.required ? '' : '?' }}: {{ prop.type | default('string') }};
    {% endfor %}
    }
    
    export interface Create{{ figma.component_name }}Request {
      name: string;
      description?: string;
      status?: 'active' | 'inactive';
    {% for prop in figma.properties %}
      {{ prop.name }}{{ prop.required ? '' : '?' }}: {{ prop.type | default('string') }};
    {% endfor %}
    }
    
    export interface Update{{ figma.component_name }}Request {
      name?: string;
      description?: string;
      status?: 'active' | 'inactive';
    {% for prop in figma.properties %}
      {{ prop.name }}?: {{ prop.type | default('string') }};
    {% endfor %}
    }
    
    export interface FindManyOptions {
      page: number;
      limit: number;
      search?: string;
      sortBy?: string;
      sortOrder?: 'asc' | 'desc';
    }
    
    export interface PaginatedResponse<T> {
      items: T[];
      total: number;
      page: number;
      limit: number;
    }
    
    export interface ApiResponse<T = any> {
      success: boolean;
      data?: T;
      error?: {
        code: string;
        message: string;
        details?: any;
      };
    }

# Documentation Templates
documentation_template:
  api_docs: |
    # {{ figma.component_name }} API Documentation
    
    ## Overview
    
    The {{ figma.component_name }} API provides endpoints for managing {{ figma.component_name | kebabCase }} resources.
    
    **Base URL**: `https://api.{{ project.name | kebabCase }}.com/v1`
    
    ## Authentication
    
    All API endpoints require authentication via Bearer token:
    
    ```bash
    Authorization: Bearer <your-jwt-token>
    ```
    
    ## Endpoints
    
    ### GET /{{ figma.component_name | kebabCase }}
    
    Retrieve a paginated list of {{ figma.component_name | kebabCase }} items.
    
    **Query Parameters:**
    - `page` (number): Page number (default: 1)
    - `limit` (number): Items per page (default: 20, max: 100)
    - `search` (string): Search query for filtering
    - `sortBy` (string): Field to sort by
    - `sortOrder` (string): Sort order ('asc' or 'desc')
    
    **Response:**
    ```json
    {
      "success": true,
      "data": [
        {
          "id": "uuid",
          "name": "{{ figma.component_name }} Name",
          "description": "Description",
          "status": "active",
          "createdAt": "2025-10-30T12:00:00Z",
          "updatedAt": "2025-10-30T12:00:00Z"
        }
      ],
      "pagination": {
        "page": 1,
        "limit": 20,
        "total": 100,
        "pages": 5
      }
    }
    ```
    
    ### POST /{{ figma.component_name | kebabCase }}
    
    Create a new {{ figma.component_name | kebabCase }} item.
    
    **Request Body:**
    ```json
    {
      "name": "{{ figma.component_name }} Name",
      "description": "Optional description",
      "status": "active"
    }
    ```
    
    **Response:**
    ```json
    {
      "success": true,
      "data": {
        "id": "uuid",
        "name": "{{ figma.component_name }} Name",
        "description": "Optional description",
        "status": "active",
        "createdAt": "2025-10-30T12:00:00Z",
        "updatedAt": "2025-10-30T12:00:00Z"
      }
    }
    ```
    
    ### GET /{{ figma.component_name | kebabCase }}/:id
    
    Retrieve a specific {{ figma.component_name | kebabCase }} item by ID.
    
    **Response:**
    ```json
    {
      "success": true,
      "data": {
        "id": "uuid",
        "name": "{{ figma.component_name }} Name",
        "description": "Description",
        "status": "active",
        "createdAt": "2025-10-30T12:00:00Z",
        "updatedAt": "2025-10-30T12:00:00Z"
      }
    }
    ```
    
    ### PUT /{{ figma.component_name | kebabCase }}/:id
    
    Update an existing {{ figma.component_name | kebabCase }} item.
    
    **Request Body:**
    ```json
    {
      "name": "Updated Name",
      "description": "Updated description",
      "status": "inactive"
    }
    ```
    
    ### DELETE /{{ figma.component_name | kebabCase }}/:id
    
    Delete a {{ figma.component_name | kebabCase }} item.
    
    **Response:** `204 No Content`
    
    ## Error Responses
    
    ```json
    {
      "success": false,
      "error": {
        "code": "ERROR_CODE",
        "message": "Human readable error message",
        "details": {
          "field": "specific error details"
        }
      }
    }
    ```
    
    ### Error Codes
    
    - `VALIDATION_ERROR`: Request validation failed
    - `NOT_FOUND`: Resource not found
    - `UNAUTHORIZED`: Authentication required
    - `FORBIDDEN`: Insufficient permissions
    - `INTERNAL_ERROR`: Server error
    
    ## Rate Limiting
    
    - **Rate Limit**: 100 requests per minute per API key
    - **Headers**: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`
    
    ## SDK Examples
    
    ### Node.js/TypeScript
    
    ```typescript
    import { {{ figma.component_name }}Client } from '@{{ project.name }}/api-client';
    
    const client = new {{ figma.component_name }}Client({
      baseURL: 'https://api.{{ project.name | kebabCase }}.com/v1',
      apiKey: 'your-api-key'
    });
    
    // List items
    const items = await client.{{ figma.component_name | camelCase }}.list({
      page: 1,
      limit: 20
    });
    
    // Create item
    const newItem = await client.{{ figma.component_name | camelCase }}.create({
      name: '{{ figma.component_name }} Name',
      description: 'Description'
    });
    
    // Get item by ID
    const item = await client.{{ figma.component_name | camelCase }}.getById('item-id');
    
    // Update item
    const updatedItem = await client.{{ figma.component_name | camelCase }}.update('item-id', {
      name: 'Updated Name'
    });
    
    // Delete item
    await client.{{ figma.component_name | camelCase }}.delete('item-id');
    ```